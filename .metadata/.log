!SESSION 2023-09-14 14:45:11.379 -----------------------------------------------
eclipse.buildId=4.28.0.20230608-1200
java.version=17.0.8.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\ITSC\Desktop\miniproject\miniproject\.metadata\.bak_3.log
Created Time: 2023-09-14 16:08:15.944

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-14 16:08:15.944
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-14 16:08:15.944
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-14 16:08:16.010
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package player;

import java.awt.Color;
import java.awt.Font;
import java.io.File;
import java.net.Socket;
import java.util.Vector;

import javax.imageio.ImageIO;
import javax.imageio.ImageTranscoder;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.xml.stream.events.StartDocument;

import player.Player;
import sword.SwordControl;
import SpriteSheet.SpriteSheet;
import imgSize.*;
import lombok.Data;
import monster.Monster;
import monster.Worm;

@Data

public class issac extends Player {
	private final static String TAG = "issac: ";
	private issac issac = this;
	private SpriteSheet ssHead, ssBody;
	private SpriteSheet ssTotal;
	private Vector<SpriteSheet> ssLife;
	private SwordControl swordControl;
	private Worm worm;
	private Vector<Monster> monsters;
	private Vector<wall> walls;
	private Vector<Item> items;
	private int xPlusBody = 7, yPlusBody = 30;
	private int yTotalSize;
	private int item1Count = 0;
	private int item2Count = 0;
	private int item3Count = 0;
	private int item4Count = 0;
	private int moveSpeed = 10;
	// 상하 좌우 이동 모션
	// 개수 및 수치 표시용 레이블 + 변수 선언 및 초기화
	private JLabel labomb;
	private JLabel laspeed;
	private JLabel lapower;
	private JLabel laattackspeed;
	private int bombCount = 0;
	private int speedNum = 11;
	private int powerNum = 1;
	private int attackspeedNum = 1;
	public issac(JFrame app, Vector<Monster> monsters ,  Vector<wall> walls, Vector<Item> items) {
		super(app);
		System.out.println(TAG + "make issac");
		init(monsters ,walls, items);
		setting();
		batch();

	}

	public void init(Vector<Monster> monsters ,Vector<wall> walls, Vector<Item> items) {
		this.walls = walls;
		this.items = items;
		this.monsters = monsters;
		ssHead = new SpriteSheet("issac/issac.png", "issacssHead", 0, 0, issacSize.issacHEADWIDTH,
				issacSize.issacHEADHEIGHT);
		ssBody = new SpriteSheet("issac/issac.png", "issacBody", 0, (issacSize.issacHEADHEIGHT + Gap.ROWGAP),
				issacSize.issacBODYWIDTH, issacSize.issacBODYHEIGHT);
		ssTotal = new SpriteSheet("issac/issac.png", "issacsBody", 0, yTotalSize, issacSize.issacTOTALWIDTH,
				issacSize.issacTOTALHEIGHT);
		yTotalSize = issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 4 + Gap.ROWGAP * 5;
		// 레이블 초기화
		labomb = new JLabel(Integer.toString(bombCount));
		laspeed = new JLabel(Integer.toString(speedNum - moveSpeed));
		lapower = new JLabel(Integer.toString(powerNum));
		laattackspeed = new JLabel(Integer.toString(attackspeedNum));
		ssLife = new Vector<SpriteSheet>();
		for (int i = 0; i < getLife(); i++) {
			this.ssLife.add(i,
					new SpriteSheet("issac/life.png", "life", 0, 0, Lifesize.LIFEWIDTH, Lifesize.LIFEHEIGHT));
		}
		for (int i = (int) getLife(); i < getMaxlife(); i++) {
			this.ssLife.add(new SpriteSheet("issac/life.png", "life", Lifesize.LIFEWIDTH * 2, 0, Lifesize.LIFEWIDTH,
					Lifesize.LIFEHEIGHT));
		}
	}

	public void setting() {
		setViewDirect(ViewDirect.DOWN);
		setXPlayer(480);
		setYPlayer(430);
		setAttackDamge(1);
		setLife(3);
		setXPlayerCenter(getXPlayer() + issacSize.issacHEADWIDTH / 2);
		setYPlayerCenter(getYPlayer() + issacSize.issacHEADHEIGHT);
		ssHead.drawObj(getXPlayer(), getYPlayer());
		ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
		// 폭탄 레이블 설정
		labomb.setSize(30, 30);
		labomb.setLocation(65, 50);
		labomb.setFont(new Font("바탕", Font.ITALIC, 25));
		labomb.setForeground(Color.WHITE);
		// 속도 레이블 설정
		lapower.setSize(30, 30);
		lapower.setLocation(65, 85);
		lapower.setFont(new Font("바탕", Font.ITALIC, 25));
		lapower.setForeground(Color.WHITE);
		// 속도 레이블 설정
		laspeed.setSize(40, 30);
		laspeed.setLocation(65, 120);
		laspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laspeed.setForeground(Color.WHITE);
		// 공속 레이블 설정
		laattackspeed.setSize(40,30);
		laattackspeed.setLocation(65, 155);
		laattackspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laattackspeed.setForeground(Color.WHITE);
		
		for (int i = 0; i < getMaxlife(); i++) {
			if (i <= getLife()) {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			} else {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			}

		}
	}

	public void batch() {
		getApp().add(ssHead, 0);
		getApp().add(ssBody, 1);
		// 폭탄 파워 속도 레이블 추가
		getApp().add(labomb);
		getApp().add(lapower);
		getApp().add(laspeed);
		getApp().add(laattackspeed);
		swordControl = new SwordControl(getApp());
		for (int i = 0; i < getMaxlife(); i++) {
			getApp().add(ssLife.get(i), 1);
		}
	}

	// 상하 좌우 이동 모션
	@Override
	public void moveRight() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isRight() == false) {
					setRight(true);
					setViewDirect(ViewDirect.RIGHT);
					while (isRight()) {
						if (getXPlayer() + issacSize.issacBODYWIDTH > 810) { // 벽이상 움직임 제한
							setRight(false);
							refreshDirect();
							break;
						}
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						setXPlayer(getXPlayer()+1);
						setXPlayerCenter(getXPlayerCenter()+1);
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall()
										&& getXPlayerCenter() < walls.get(i).getXwall() + RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setRight(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveLeft() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isLeft() == false) {
					setLeft(true);
					setViewDirect(ViewDirect.LEFT);
					while (isLeft()) {
						if (getXPlayer() < 130) {
							setLeft(false);
							refreshDirect();
							break;
						}
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {

								if (getXPlayerCenter() > walls.get(i).getXwall()
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setLeft(false);
							refreshDirect();
							break;
						}
						// 돌 충돌 체크 끝
						getItem();
						setXPlayer(getXPlayer() - 1);
						setXPlayerCenter(getXPlayerCenter() - 1);
						moveMotion();
						try {

							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveDown() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isDown() == false) {
					setDown(true);
					setViewDirect(ViewDirect.DOWN);
					while (isDown()) {
						if (getYPlayer() > 440) {
							setDown(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() + (issacSize.issacHEADHEIGHT - yPlusBody) + 5 > walls
												.get(i).getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveUp() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isUp() == false) {
					setUp(true);
					setViewDirect(ViewDirect.UP);
					while (isUp()) {
						if(getYPlayer()<100) {
							setUp(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer()-1);
						setYPlayerCenter(getYPlayerCenter()-1);
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() > walls.get(i).getYwall() && getYPlayerCenter()
												+ (issacSize.issacBODYHEIGHT - yPlusBody) < walls.get(i).getYwall()
														+ RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() - 1);
						setYPlayerCenter(getYPlayerCenter() - 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// // 가져올
																											// 기준이
							// 되는 X좌표가
							// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// // 않게하기위해 사용합니다.
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_down.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
								}
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_left.png"))
										swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
								}
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_up.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
								}
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_right.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
								}
=======
						}	
=======
						}
>>>>>>> origin/최낙연
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override // Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// 가져올 기준이
																											// 되는 X좌표가
																											// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// 않게하기위해 사용합니다.
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
<<<<<<< HEAD
								ssBody.drawObj(getXPlayer()+xPlusBody, getYPlayer()+yPlusBody);
>>>>>>> origin/최낙연
=======
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
>>>>>>> origin/최낙연
								motion += 1;
							}
						}
						try {
<<<<<<< HEAD
							Thread.sleep(15);
=======
							Thread.sleep(40);
>>>>>>> origin/최낙연
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
<<<<<<< HEAD
<<<<<<< HEAD

			}
		}).start();
	}

	public synchronized void attackMotion() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isPlayerAttack() == false) {
					setPlayerAttack(true);
					if (isPlayerAttack()) {
						int imgxlocation = 1;
						int imgylocation = 0;
						while (true) {
							setPlayerAttacking(true);
							if (getViewDirect() == ViewDirect.DOWN) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setXPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - (SwordMotionSize.IMGHEIGHT)
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_down.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() + 25);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.UP) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword()
										.setXPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.IMGHEIGHT - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_up.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() - 50);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.LEFT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos((SwordMotionSize.IMGHEIGHT) - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setUrl("sword/sword_left.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 60, getYPlayer() - 10);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.RIGHT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordMotionSize.IMGHEIGHT
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword()
										.setYPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setUrl("sword/sword_right.png");
								swordControl.getSsSword().drawObj(getXPlayer() + 20, getYPlayer() - 10);
								imgylocation++;
							}
							try {
								Thread.sleep(20);
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
				}
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	public void reDrawLife() {
		double currentLife = getLife();
		for (int i = 0; i < getMaxlife(); i++) {
			if (currentLife >= 1) {
				ssLife.get(i).setXPos(0);
				currentLife -= 1;
			} else if (currentLife > 0 && currentLife < 1) {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH + Gap.COLUMGAP);
				currentLife -= 0.5;
			} else {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH * 2 + Gap.COLUMGAP * 2);
			}

		}
	}

	public void attack() {
	}
}
=======
				
=======

>>>>>>> origin/최낙연
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	// 주변 아이템 여부 체크
	public boolean nearItemCheck(Item item) {
		if (getXPlayerCenter() > item.getXItem() && getXPlayerCenter() < item.getXItem() + item.getSsItem().getWidth()
				&& getYPlayerCenter() > item.getYItem()
				&& getYPlayerCenter() < item.getYItem() + item.getSsItem().getHeight()) {
			return true;
		} else {
			return false;
		}
	}

	// 아이템 획득 종류 확인
	public void getItem() {
		for (int i = 0; i < items.size(); i++) {
			if (items.get(i).isDrop()) {
				if (nearItemCheck(items.get(i))) {
					items.get(i).setDrop(false);
					// Gubun String이 "bomb" 일때
					int luck = (int) (Math.random() * 2);

					if (items.get(i).getSsItem().getGubun() == "bomb") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {
							bombCount += 1;
							labomb.setText(Integer.toString(bombCount));
						} else if (luck == 0) {
							bombCount -= 1;
							labomb.setText(Integer.toString(bombCount));
						} // Gubun String이 "Power" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Power") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							powerNum+=2;
							lapower.setText(Integer.toString(powerNum));
								
						}
						else if(luck == 0) {
							powerNum--;
							lapower.setText(Integer.toString(powerNum));
							
						}
						// Gubun String이 "Speed" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Speed") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							moveSpeed += 3;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));

						}
						else if ( luck == 0) {
							moveSpeed --;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));
							
						}
					}
					else if (items.get(i).getSsItem().getGubun() == "AttackSpeed") {
						if (luck == 1) {

							attackspeedNum +=2;
							laattackspeed.setText(Integer.toString(attackspeedNum));

						}
						else if ( luck == 0) {
							attackspeedNum --;
							laattackspeed.setText(Integer.toString(attackspeedNum));
							
						}
					}
					System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
					getApp().remove(items.get(i).getSsItem());
					getApp().repaint();

				}
			}

		}
	}
}
>>>>>>> origin/최낙연

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1008)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:804)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:748)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:671)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:663)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-14 16:08:16.011
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1008)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:804)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:748)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:671)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:663)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-14 16:08:16.011
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoveredASTNode(JavadocHover.java:1008)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getInfoText(JavadocHover.java:804)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo(JavadocHover.java:748)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.internalGetHoverInfo(JavadocHover.java:671)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover.getHoverInfo2(JavadocHover.java:663)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-14 16:08:26.811
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package player;

import java.awt.Color;
import java.awt.Font;
import java.io.File;
import java.net.Socket;
import java.util.Vector;

import javax.imageio.ImageIO;
import javax.imageio.ImageTranscoder;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.xml.stream.events.StartDocument;

import player.Player;
import sword.SwordControl;
import SpriteSheet.SpriteSheet;
import imgSize.*;
import lombok.Data;
import monster.Monster;
import monster.Worm;

@Data

public class issac extends Player {
	private final static String TAG = "issac: ";
	private issac issac = this;
	private SpriteSheet ssHead, ssBody;
	private SpriteSheet ssTotal;
	private Vector<SpriteSheet> ssLife;
	private SwordControl swordControl;
	private Worm worm;
	private Vector<Monster> monsters;
	private Vector<wall> walls;
	private Vector<Item> items;
	private int xPlusBody = 7, yPlusBody = 30;
	private int yTotalSize;
	private int item1Count = 0;
	private int item2Count = 0;
	private int item3Count = 0;
	private int item4Count = 0;
	private int moveSpeed = 10;
	// 상하 좌우 이동 모션
	// 개수 및 수치 표시용 레이블 + 변수 선언 및 초기화
	private JLabel labomb;
	private JLabel laspeed;
	private JLabel lapower;
	private JLabel laattackspeed;
	private int bombCount = 0;
	private int speedNum = 11;
	private int powerNum = 1;
	private int attackspeedNum = 1;
	public issac(JFrame app, Vector<Monster> monsters ,  Vector<wall> walls, Vector<Item> items) {
		super(app);
		System.out.println(TAG + "make issac");
		init(monsters ,walls, items);
		setting();
		batch();

	}

	public void init(Vector<Monster> monsters ,Vector<wall> walls, Vector<Item> items) {
		this.walls = walls;
		this.items = items;
		this.monsters = monsters;
		ssHead = new SpriteSheet("issac/issac.png", "issacssHead", 0, 0, issacSize.issacHEADWIDTH,
				issacSize.issacHEADHEIGHT);
		ssBody = new SpriteSheet("issac/issac.png", "issacBody", 0, (issacSize.issacHEADHEIGHT + Gap.ROWGAP),
				issacSize.issacBODYWIDTH, issacSize.issacBODYHEIGHT);
		ssTotal = new SpriteSheet("issac/issac.png", "issacsBody", 0, yTotalSize, issacSize.issacTOTALWIDTH,
				issacSize.issacTOTALHEIGHT);
		yTotalSize = issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 4 + Gap.ROWGAP * 5;
		// 레이블 초기화
		labomb = new JLabel(Integer.toString(bombCount));
		laspeed = new JLabel(Integer.toString(speedNum - moveSpeed));
		lapower = new JLabel(Integer.toString(powerNum));
		laattackspeed = new JLabel(Integer.toString(attackspeedNum));
		ssLife = new Vector<SpriteSheet>();
		for (int i = 0; i < getLife(); i++) {
			this.ssLife.add(i,
					new SpriteSheet("issac/life.png", "life", 0, 0, Lifesize.LIFEWIDTH, Lifesize.LIFEHEIGHT));
		}
		for (int i = (int) getLife(); i < getMaxlife(); i++) {
			this.ssLife.add(new SpriteSheet("issac/life.png", "life", Lifesize.LIFEWIDTH * 2, 0, Lifesize.LIFEWIDTH,
					Lifesize.LIFEHEIGHT));
		}
	}

	public void setting() {
		setViewDirect(ViewDirect.DOWN);
		setXPlayer(480);
		setYPlayer(430);
		setAttackDamge(1);
		setLife(3);
		setXPlayerCenter(getXPlayer() + issacSize.issacHEADWIDTH / 2);
		setYPlayerCenter(getYPlayer() + issacSize.issacHEADHEIGHT);
		ssHead.drawObj(getXPlayer(), getYPlayer());
		ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
		// 폭탄 레이블 설정
		labomb.setSize(30, 30);
		labomb.setLocation(65, 50);
		labomb.setFont(new Font("바탕", Font.ITALIC, 25));
		labomb.setForeground(Color.WHITE);
		// 속도 레이블 설정
		lapower.setSize(30, 30);
		lapower.setLocation(65, 85);
		lapower.setFont(new Font("바탕", Font.ITALIC, 25));
		lapower.setForeground(Color.WHITE);
		// 속도 레이블 설정
		laspeed.setSize(40, 30);
		laspeed.setLocation(65, 120);
		laspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laspeed.setForeground(Color.WHITE);
		// 공속 레이블 설정
		laattackspeed.setSize(40,30);
		laattackspeed.setLocation(65, 155);
		laattackspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laattackspeed.setForeground(Color.WHITE);
		
		for (int i = 0; i < getMaxlife(); i++) {
			if (i <= getLife()) {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			} else {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			}

		}
	}

	public void batch() {
		getApp().add(ssHead, 0);
		getApp().add(ssBody, 1);
		// 폭탄 파워 속도 레이블 추가
		getApp().add(labomb);
		getApp().add(lapower);
		getApp().add(laspeed);
		getApp().add(laattackspeed);
		swordControl = new SwordControl(getApp());
		for (int i = 0; i < getMaxlife(); i++) {
			getApp().add(ssLife.get(i), 1);
		}
	}

	// 상하 좌우 이동 모션
	@Override
	public void moveRight() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isRight() == false) {
					setRight(true);
					setViewDirect(ViewDirect.RIGHT);
					while (isRight()) {
						if (getXPlayer() + issacSize.issacBODYWIDTH > 810) { // 벽이상 움직임 제한
							setRight(false);
							refreshDirect();
							break;
						}
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						setXPlayer(getXPlayer()+1);
						setXPlayerCenter(getXPlayerCenter()+1);
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall()
										&& getXPlayerCenter() < walls.get(i).getXwall() + RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setRight(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveLeft() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isLeft() == false) {
					setLeft(true);
					setViewDirect(ViewDirect.LEFT);
					while (isLeft()) {
						if (getXPlayer() < 130) {
							setLeft(false);
							refreshDirect();
							break;
						}
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {

								if (getXPlayerCenter() > walls.get(i).getXwall()
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setLeft(false);
							refreshDirect();
							break;
						}
						// 돌 충돌 체크 끝
						getItem();
						setXPlayer(getXPlayer() - 1);
						setXPlayerCenter(getXPlayerCenter() - 1);
						moveMotion();
						try {

							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveDown() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isDown() == false) {
					setDown(true);
					setViewDirect(ViewDirect.DOWN);
					while (isDown()) {
						if (getYPlayer() > 440) {
							setDown(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() + (issacSize.issacHEADHEIGHT - yPlusBody) + 5 > walls
												.get(i).getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveUp() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isUp() == false) {
					setUp(true);
					setViewDirect(ViewDirect.UP);
					while (isUp()) {
						if(getYPlayer()<100) {
							setUp(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer()-1);
						setYPlayerCenter(getYPlayerCenter()-1);
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() > walls.get(i).getYwall() && getYPlayerCenter()
												+ (issacSize.issacBODYHEIGHT - yPlusBody) < walls.get(i).getYwall()
														+ RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() - 1);
						setYPlayerCenter(getYPlayerCenter() - 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// // 가져올
																											// 기준이
							// 되는 X좌표가
							// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// // 않게하기위해 사용합니다.
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_down.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
								}
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_left.png"))
										swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
								}
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_up.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
								}
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_right.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
								}
=======
						}	
=======
						}
>>>>>>> origin/최낙연
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override // Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// 가져올 기준이
																											// 되는 X좌표가
																											// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// 않게하기위해 사용합니다.
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
<<<<<<< HEAD
								ssBody.drawObj(getXPlayer()+xPlusBody, getYPlayer()+yPlusBody);
>>>>>>> origin/최낙연
=======
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
>>>>>>> origin/최낙연
								motion += 1;
							}
						}
						try {
<<<<<<< HEAD
							Thread.sleep(15);
=======
							Thread.sleep(40);
>>>>>>> origin/최낙연
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
<<<<<<< HEAD
<<<<<<< HEAD

			}
		}).start();
	}

	public synchronized void attackMotion() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isPlayerAttack() == false) {
					setPlayerAttack(true);
					if (isPlayerAttack()) {
						int imgxlocation = 1;
						int imgylocation = 0;
						while (true) {
							setPlayerAttacking(true);
							if (getViewDirect() == ViewDirect.DOWN) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setXPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - (SwordMotionSize.IMGHEIGHT)
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_down.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() + 25);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.UP) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword()
										.setXPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.IMGHEIGHT - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_up.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() - 50);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.LEFT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos((SwordMotionSize.IMGHEIGHT) - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setUrl("sword/sword_left.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 60, getYPlayer() - 10);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.RIGHT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordMotionSize.IMGHEIGHT
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword()
										.setYPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setUrl("sword/sword_right.png");
								swordControl.getSsSword().drawObj(getXPlayer() + 20, getYPlayer() - 10);
								imgylocation++;
							}
							try {
								Thread.sleep(20);
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
				}
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	public void reDrawLife() {
		double currentLife = getLife();
		for (int i = 0; i < getMaxlife(); i++) {
			if (currentLife >= 1) {
				ssLife.get(i).setXPos(0);
				currentLife -= 1;
			} else if (currentLife > 0 && currentLife < 1) {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH + Gap.COLUMGAP);
				currentLife -= 0.5;
			} else {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH * 2 + Gap.COLUMGAP * 2);
			}

		}
	}

	public void attack() {
	}
}
=======
				
=======

>>>>>>> origin/최낙연
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	// 주변 아이템 여부 체크
	public boolean nearItemCheck(Item item) {
		if (getXPlayerCenter() > item.getXItem() && getXPlayerCenter() < item.getXItem() + item.getSsItem().getWidth()
				&& getYPlayerCenter() > item.getYItem()
				&& getYPlayerCenter() < item.getYItem() + item.getSsItem().getHeight()) {
			return true;
		} else {
			return false;
		}
	}

	// 아이템 획득 종류 확인
	public void getItem() {
		for (int i = 0; i < items.size(); i++) {
			if (items.get(i).isDrop()) {
				if (nearItemCheck(items.get(i))) {
					items.get(i).setDrop(false);
					// Gubun String이 "bomb" 일때
					int luck = (int) (Math.random() * 2);

					if (items.get(i).getSsItem().getGubun() == "bomb") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {
							bombCount += 1;
							labomb.setText(Integer.toString(bombCount));
						} else if (luck == 0) {
							bombCount -= 1;
							labomb.setText(Integer.toString(bombCount));
						} // Gubun String이 "Power" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Power") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							powerNum+=2;
							lapower.setText(Integer.toString(powerNum));
								
						}
						else if(luck == 0) {
							powerNum--;
							lapower.setText(Integer.toString(powerNum));
							
						}
						// Gubun String이 "Speed" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Speed") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							moveSpeed += 3;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));

						}
						else if ( luck == 0) {
							moveSpeed --;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));
							
						}
					}
					else if (items.get(i).getSsItem().getGubun() == "AttackSpeed") {
						if (luck == 1) {

							attackspeedNum +=2;
							laattackspeed.setText(Integer.toString(attackspeedNum));

						}
						else if ( luck == 0) {
							attackspeedNum --;
							laattackspeed.setText(Integer.toString(attackspeedNum));
							
						}
					}
					System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
					getApp().remove(items.get(i).getSsItem());
					getApp().repaint();

				}
			}

		}
	}
}
>>>>>>> origin/최낙연

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-14 16:08:26.811
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-14 16:08:26.811
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-14 16:08:29.798
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package player;

import java.awt.Color;
import java.awt.Font;
import java.io.File;
import java.net.Socket;
import java.util.Vector;

import javax.imageio.ImageIO;
import javax.imageio.ImageTranscoder;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.xml.stream.events.StartDocument;

import player.Player;
import sword.SwordControl;
import SpriteSheet.SpriteSheet;
import imgSize.*;
import lombok.Data;
import monster.Monster;
import monster.Worm;

@Data

public class issac extends Player {
	private final static String TAG = "issac: ";
	private issac issac = this;
	private SpriteSheet ssHead, ssBody;
	private SpriteSheet ssTotal;
	private Vector<SpriteSheet> ssLife;
	private SwordControl swordControl;
	private Worm worm;
	private Vector<Monster> monsters;
	private Vector<wall> walls;
	private Vector<Item> items;
	private int xPlusBody = 7, yPlusBody = 30;
	private int yTotalSize;
	private int item1Count = 0;
	private int item2Count = 0;
	private int item3Count = 0;
	private int item4Count = 0;
	private int moveSpeed = 10;
	// 상하 좌우 이동 모션
	// 개수 및 수치 표시용 레이블 + 변수 선언 및 초기화
	private JLabel labomb;
	private JLabel laspeed;
	private JLabel lapower;
	private JLabel laattackspeed;
	private int bombCount = 0;
	private int speedNum = 11;
	private int powerNum = 1;
	private int attackspeedNum = 1;
	public issac(JFrame app, Vector<Monster> monsters ,  Vector<wall> walls, Vector<Item> items) {
		super(app);
		System.out.println(TAG + "make issac");
		init(monsters ,walls, items);
		setting();
		batch();

	}

	public void init(Vector<Monster> monsters ,Vector<wall> walls, Vector<Item> items) {
		this.walls = walls;
		this.items = items;
		this.monsters = monsters;
		ssHead = new SpriteSheet("issac/issac.png", "issacssHead", 0, 0, issacSize.issacHEADWIDTH,
				issacSize.issacHEADHEIGHT);
		ssBody = new SpriteSheet("issac/issac.png", "issacBody", 0, (issacSize.issacHEADHEIGHT + Gap.ROWGAP),
				issacSize.issacBODYWIDTH, issacSize.issacBODYHEIGHT);
		ssTotal = new SpriteSheet("issac/issac.png", "issacsBody", 0, yTotalSize, issacSize.issacTOTALWIDTH,
				issacSize.issacTOTALHEIGHT);
		yTotalSize = issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 4 + Gap.ROWGAP * 5;
		// 레이블 초기화
		labomb = new JLabel(Integer.toString(bombCount));
		laspeed = new JLabel(Integer.toString(speedNum - moveSpeed));
		lapower = new JLabel(Integer.toString(powerNum));
		laattackspeed = new JLabel(Integer.toString(attackspeedNum));
		ssLife = new Vector<SpriteSheet>();
		for (int i = 0; i < getLife(); i++) {
			this.ssLife.add(i,
					new SpriteSheet("issac/life.png", "life", 0, 0, Lifesize.LIFEWIDTH, Lifesize.LIFEHEIGHT));
		}
		for (int i = (int) getLife(); i < getMaxlife(); i++) {
			this.ssLife.add(new SpriteSheet("issac/life.png", "life", Lifesize.LIFEWIDTH * 2, 0, Lifesize.LIFEWIDTH,
					Lifesize.LIFEHEIGHT));
		}
	}

	public void setting() {
		setViewDirect(ViewDirect.DOWN);
		setXPlayer(480);
		setYPlayer(430);
		setAttackDamge(1);
		setLife(3);
		setXPlayerCenter(getXPlayer() + issacSize.issacHEADWIDTH / 2);
		setYPlayerCenter(getYPlayer() + issacSize.issacHEADHEIGHT);
		ssHead.drawObj(getXPlayer(), getYPlayer());
		ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
		// 폭탄 레이블 설정
		labomb.setSize(30, 30);
		labomb.setLocation(65, 50);
		labomb.setFont(new Font("바탕", Font.ITALIC, 25));
		labomb.setForeground(Color.WHITE);
		// 속도 레이블 설정
		lapower.setSize(30, 30);
		lapower.setLocation(65, 85);
		lapower.setFont(new Font("바탕", Font.ITALIC, 25));
		lapower.setForeground(Color.WHITE);
		// 속도 레이블 설정
		laspeed.setSize(40, 30);
		laspeed.setLocation(65, 120);
		laspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laspeed.setForeground(Color.WHITE);
		// 공속 레이블 설정
		laattackspeed.setSize(40,30);
		laattackspeed.setLocation(65, 155);
		laattackspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laattackspeed.setForeground(Color.WHITE);
		
		for (int i = 0; i < getMaxlife(); i++) {
			if (i <= getLife()) {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			} else {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			}

		}
	}

	public void batch() {
		getApp().add(ssHead, 0);
		getApp().add(ssBody, 1);
		// 폭탄 파워 속도 레이블 추가
		getApp().add(labomb);
		getApp().add(lapower);
		getApp().add(laspeed);
		getApp().add(laattackspeed);
		swordControl = new SwordControl(getApp());
		for (int i = 0; i < getMaxlife(); i++) {
			getApp().add(ssLife.get(i), 1);
		}
	}

	// 상하 좌우 이동 모션
	@Override
	public void moveRight() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isRight() == false) {
					setRight(true);
					setViewDirect(ViewDirect.RIGHT);
					while (isRight()) {
						if (getXPlayer() + issacSize.issacBODYWIDTH > 810) { // 벽이상 움직임 제한
							setRight(false);
							refreshDirect();
							break;
						}
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						setXPlayer(getXPlayer()+1);
						setXPlayerCenter(getXPlayerCenter()+1);
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall()
										&& getXPlayerCenter() < walls.get(i).getXwall() + RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setRight(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveLeft() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isLeft() == false) {
					setLeft(true);
					setViewDirect(ViewDirect.LEFT);
					while (isLeft()) {
						if (getXPlayer() < 130) {
							setLeft(false);
							refreshDirect();
							break;
						}
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {

								if (getXPlayerCenter() > walls.get(i).getXwall()
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setLeft(false);
							refreshDirect();
							break;
						}
						// 돌 충돌 체크 끝
						getItem();
						setXPlayer(getXPlayer() - 1);
						setXPlayerCenter(getXPlayerCenter() - 1);
						moveMotion();
						try {

							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveDown() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isDown() == false) {
					setDown(true);
					setViewDirect(ViewDirect.DOWN);
					while (isDown()) {
						if (getYPlayer() > 440) {
							setDown(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() + (issacSize.issacHEADHEIGHT - yPlusBody) + 5 > walls
												.get(i).getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveUp() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isUp() == false) {
					setUp(true);
					setViewDirect(ViewDirect.UP);
					while (isUp()) {
						if(getYPlayer()<100) {
							setUp(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer()-1);
						setYPlayerCenter(getYPlayerCenter()-1);
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() > walls.get(i).getYwall() && getYPlayerCenter()
												+ (issacSize.issacBODYHEIGHT - yPlusBody) < walls.get(i).getYwall()
														+ RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() - 1);
						setYPlayerCenter(getYPlayerCenter() - 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// // 가져올
																											// 기준이
							// 되는 X좌표가
							// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// // 않게하기위해 사용합니다.
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_down.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
								}
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_left.png"))
										swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
								}
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_up.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
								}
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_right.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
								}
=======
						}	
=======
						}
>>>>>>> origin/최낙연
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override // Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// 가져올 기준이
																											// 되는 X좌표가
																											// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// 않게하기위해 사용합니다.
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer()+xPlusBody, getYPlayer()+yPlusBody);
>>>>>>> origin/최낙연
=======
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
>>>>>>> origin/최낙연
								motion += 1;
							}
						}
						try {
<<<<<<< HEAD
							Thread.sleep(15);
=======
							Thread.sleep(40);
>>>>>>> origin/최낙연
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
<<<<<<< HEAD
<<<<<<< HEAD

			}
		}).start();
	}

	public synchronized void attackMotion() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isPlayerAttack() == false) {
					setPlayerAttack(true);
					if (isPlayerAttack()) {
						int imgxlocation = 1;
						int imgylocation = 0;
						while (true) {
							setPlayerAttacking(true);
							if (getViewDirect() == ViewDirect.DOWN) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setXPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - (SwordMotionSize.IMGHEIGHT)
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_down.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() + 25);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.UP) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword()
										.setXPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.IMGHEIGHT - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_up.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() - 50);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.LEFT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos((SwordMotionSize.IMGHEIGHT) - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setUrl("sword/sword_left.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 60, getYPlayer() - 10);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.RIGHT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordMotionSize.IMGHEIGHT
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword()
										.setYPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setUrl("sword/sword_right.png");
								swordControl.getSsSword().drawObj(getXPlayer() + 20, getYPlayer() - 10);
								imgylocation++;
							}
							try {
								Thread.sleep(20);
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
				}
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	public void reDrawLife() {
		double currentLife = getLife();
		for (int i = 0; i < getMaxlife(); i++) {
			if (currentLife >= 1) {
				ssLife.get(i).setXPos(0);
				currentLife -= 1;
			} else if (currentLife > 0 && currentLife < 1) {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH + Gap.COLUMGAP);
				currentLife -= 0.5;
			} else {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH * 2 + Gap.COLUMGAP * 2);
			}

		}
	}

	public void attack() {
	}
}
=======
				
=======

>>>>>>> origin/최낙연
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	// 주변 아이템 여부 체크
	public boolean nearItemCheck(Item item) {
		if (getXPlayerCenter() > item.getXItem() && getXPlayerCenter() < item.getXItem() + item.getSsItem().getWidth()
				&& getYPlayerCenter() > item.getYItem()
				&& getYPlayerCenter() < item.getYItem() + item.getSsItem().getHeight()) {
			return true;
		} else {
			return false;
		}
	}

	// 아이템 획득 종류 확인
	public void getItem() {
		for (int i = 0; i < items.size(); i++) {
			if (items.get(i).isDrop()) {
				if (nearItemCheck(items.get(i))) {
					items.get(i).setDrop(false);
					// Gubun String이 "bomb" 일때
					int luck = (int) (Math.random() * 2);

					if (items.get(i).getSsItem().getGubun() == "bomb") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {
							bombCount += 1;
							labomb.setText(Integer.toString(bombCount));
						} else if (luck == 0) {
							bombCount -= 1;
							labomb.setText(Integer.toString(bombCount));
						} // Gubun String이 "Power" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Power") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							powerNum+=2;
							lapower.setText(Integer.toString(powerNum));
								
						}
						else if(luck == 0) {
							powerNum--;
							lapower.setText(Integer.toString(powerNum));
							
						}
						// Gubun String이 "Speed" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Speed") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							moveSpeed += 3;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));

						}
						else if ( luck == 0) {
							moveSpeed --;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));
							
						}
					}
					else if (items.get(i).getSsItem().getGubun() == "AttackSpeed") {
						if (luck == 1) {

							attackspeedNum +=2;
							laattackspeed.setText(Integer.toString(attackspeedNum));

						}
						else if ( luck == 0) {
							attackspeedNum --;
							laattackspeed.setText(Integer.toString(attackspeedNum));
							
						}
					}
					System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
					getApp().remove(items.get(i).getSsItem());
					getApp().repaint();

				}
			}

		}
	}
}
>>>>>>> origin/최낙연

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-14 16:08:29.798
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-14 16:08:29.799
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-14 16:08:29.868
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package player;

import java.awt.Color;
import java.awt.Font;
import java.io.File;
import java.net.Socket;
import java.util.Vector;

import javax.imageio.ImageIO;
import javax.imageio.ImageTranscoder;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.xml.stream.events.StartDocument;

import player.Player;
import sword.SwordControl;
import SpriteSheet.SpriteSheet;
import imgSize.*;
import lombok.Data;
import monster.Monster;
import monster.Worm;

@Data

public class issac extends Player {
	private final static String TAG = "issac: ";
	private issac issac = this;
	private SpriteSheet ssHead, ssBody;
	private SpriteSheet ssTotal;
	private Vector<SpriteSheet> ssLife;
	private SwordControl swordControl;
	private Worm worm;
	private Vector<Monster> monsters;
	private Vector<wall> walls;
	private Vector<Item> items;
	private int xPlusBody = 7, yPlusBody = 30;
	private int yTotalSize;
	private int item1Count = 0;
	private int item2Count = 0;
	private int item3Count = 0;
	private int item4Count = 0;
	private int moveSpeed = 10;
	// 상하 좌우 이동 모션
	// 개수 및 수치 표시용 레이블 + 변수 선언 및 초기화
	private JLabel labomb;
	private JLabel laspeed;
	private JLabel lapower;
	private JLabel laattackspeed;
	private int bombCount = 0;
	private int speedNum = 11;
	private int powerNum = 1;
	private int attackspeedNum = 1;
	public issac(JFrame app, Vector<Monster> monsters ,  Vector<wall> walls, Vector<Item> items) {
		super(app);
		System.out.println(TAG + "make issac");
		init(monsters ,walls, items);
		setting();
		batch();

	}

	public void init(Vector<Monster> monsters ,Vector<wall> walls, Vector<Item> items) {
		this.walls = walls;
		this.items = items;
		this.monsters = monsters;
		ssHead = new SpriteSheet("issac/issac.png", "issacssHead", 0, 0, issacSize.issacHEADWIDTH,
				issacSize.issacHEADHEIGHT);
		ssBody = new SpriteSheet("issac/issac.png", "issacBody", 0, (issacSize.issacHEADHEIGHT + Gap.ROWGAP),
				issacSize.issacBODYWIDTH, issacSize.issacBODYHEIGHT);
		ssTotal = new SpriteSheet("issac/issac.png", "issacsBody", 0, yTotalSize, issacSize.issacTOTALWIDTH,
				issacSize.issacTOTALHEIGHT);
		yTotalSize = issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 4 + Gap.ROWGAP * 5;
		// 레이블 초기화
		labomb = new JLabel(Integer.toString(bombCount));
		laspeed = new JLabel(Integer.toString(speedNum - moveSpeed));
		lapower = new JLabel(Integer.toString(powerNum));
		laattackspeed = new JLabel(Integer.toString(attackspeedNum));
		ssLife = new Vector<SpriteSheet>();
		for (int i = 0; i < getLife(); i++) {
			this.ssLife.add(i,
					new SpriteSheet("issac/life.png", "life", 0, 0, Lifesize.LIFEWIDTH, Lifesize.LIFEHEIGHT));
		}
		for (int i = (int) getLife(); i < getMaxlife(); i++) {
			this.ssLife.add(new SpriteSheet("issac/life.png", "life", Lifesize.LIFEWIDTH * 2, 0, Lifesize.LIFEWIDTH,
					Lifesize.LIFEHEIGHT));
		}
	}

	public void setting() {
		setViewDirect(ViewDirect.DOWN);
		setXPlayer(480);
		setYPlayer(430);
		setAttackDamge(1);
		setLife(3);
		setXPlayerCenter(getXPlayer() + issacSize.issacHEADWIDTH / 2);
		setYPlayerCenter(getYPlayer() + issacSize.issacHEADHEIGHT);
		ssHead.drawObj(getXPlayer(), getYPlayer());
		ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
		// 폭탄 레이블 설정
		labomb.setSize(30, 30);
		labomb.setLocation(65, 50);
		labomb.setFont(new Font("바탕", Font.ITALIC, 25));
		labomb.setForeground(Color.WHITE);
		// 속도 레이블 설정
		lapower.setSize(30, 30);
		lapower.setLocation(65, 85);
		lapower.setFont(new Font("바탕", Font.ITALIC, 25));
		lapower.setForeground(Color.WHITE);
		// 속도 레이블 설정
		laspeed.setSize(40, 30);
		laspeed.setLocation(65, 120);
		laspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laspeed.setForeground(Color.WHITE);
		// 공속 레이블 설정
		laattackspeed.setSize(40,30);
		laattackspeed.setLocation(65, 155);
		laattackspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laattackspeed.setForeground(Color.WHITE);
		
		for (int i = 0; i < getMaxlife(); i++) {
			if (i <= getLife()) {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			} else {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			}

		}
	}

	public void batch() {
		getApp().add(ssHead, 0);
		getApp().add(ssBody, 1);
		// 폭탄 파워 속도 레이블 추가
		getApp().add(labomb);
		getApp().add(lapower);
		getApp().add(laspeed);
		getApp().add(laattackspeed);
		swordControl = new SwordControl(getApp());
		for (int i = 0; i < getMaxlife(); i++) {
			getApp().add(ssLife.get(i), 1);
		}
	}

	// 상하 좌우 이동 모션
	@Override
	public void moveRight() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isRight() == false) {
					setRight(true);
					setViewDirect(ViewDirect.RIGHT);
					while (isRight()) {
						if (getXPlayer() + issacSize.issacBODYWIDTH > 810) { // 벽이상 움직임 제한
							setRight(false);
							refreshDirect();
							break;
						}
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						setXPlayer(getXPlayer()+1);
						setXPlayerCenter(getXPlayerCenter()+1);
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall()
										&& getXPlayerCenter() < walls.get(i).getXwall() + RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setRight(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveLeft() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isLeft() == false) {
					setLeft(true);
					setViewDirect(ViewDirect.LEFT);
					while (isLeft()) {
						if (getXPlayer() < 130) {
							setLeft(false);
							refreshDirect();
							break;
						}
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {

								if (getXPlayerCenter() > walls.get(i).getXwall()
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setLeft(false);
							refreshDirect();
							break;
						}
						// 돌 충돌 체크 끝
						getItem();
						setXPlayer(getXPlayer() - 1);
						setXPlayerCenter(getXPlayerCenter() - 1);
						moveMotion();
						try {

							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveDown() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isDown() == false) {
					setDown(true);
					setViewDirect(ViewDirect.DOWN);
					while (isDown()) {
						if (getYPlayer() > 440) {
							setDown(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() + (issacSize.issacHEADHEIGHT - yPlusBody) + 5 > walls
												.get(i).getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveUp() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isUp() == false) {
					setUp(true);
					setViewDirect(ViewDirect.UP);
					while (isUp()) {
						if(getYPlayer()<100) {
							setUp(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer()-1);
						setYPlayerCenter(getYPlayerCenter()-1);
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() > walls.get(i).getYwall() && getYPlayerCenter()
												+ (issacSize.issacBODYHEIGHT - yPlusBody) < walls.get(i).getYwall()
														+ RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() - 1);
						setYPlayerCenter(getYPlayerCenter() - 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// // 가져올
																											// 기준이
							// 되는 X좌표가
							// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// // 않게하기위해 사용합니다.
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_down.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
								}
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_left.png"))
										swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
								}
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_up.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
								}
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_right.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
								}
=======
						}	
=======
						}
>>>>>>> origin/최낙연
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override // Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// 가져올 기준이
																											// 되는 X좌표가
																											// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// 않게하기위해 사용합니다.
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer()+xPlusBody, getYPlayer()+yPlusBody);
>>>>>>> origin/최낙연
=======
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
>>>>>>> origin/최낙연
								motion += 1;
							}
						}
						try {
<<<<<<< HEAD
							Thread.sleep(15);
=======
							Thread.sleep(40);
>>>>>>> origin/최낙연
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
<<<<<<< HEAD
<<<<<<< HEAD

			}
		}).start();
	}

	public synchronized void attackMotion() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isPlayerAttack() == false) {
					setPlayerAttack(true);
					if (isPlayerAttack()) {
						int imgxlocation = 1;
						int imgylocation = 0;
						while (true) {
							setPlayerAttacking(true);
							if (getViewDirect() == ViewDirect.DOWN) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setXPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - (SwordMotionSize.IMGHEIGHT)
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_down.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() + 25);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.UP) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword()
										.setXPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.IMGHEIGHT - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_up.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() - 50);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.LEFT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos((SwordMotionSize.IMGHEIGHT) - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setUrl("sword/sword_left.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 60, getYPlayer() - 10);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.RIGHT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordMotionSize.IMGHEIGHT
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword()
										.setYPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setUrl("sword/sword_right.png");
								swordControl.getSsSword().drawObj(getXPlayer() + 20, getYPlayer() - 10);
								imgylocation++;
							}
							try {
								Thread.sleep(20);
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
				}
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	public void reDrawLife() {
		double currentLife = getLife();
		for (int i = 0; i < getMaxlife(); i++) {
			if (currentLife >= 1) {
				ssLife.get(i).setXPos(0);
				currentLife -= 1;
			} else if (currentLife > 0 && currentLife < 1) {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH + Gap.COLUMGAP);
				currentLife -= 0.5;
			} else {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH * 2 + Gap.COLUMGAP * 2);
			}

		}
	}

	public void attack() {
	}
}
=======
				
=======

>>>>>>> origin/최낙연
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	// 주변 아이템 여부 체크
	public boolean nearItemCheck(Item item) {
		if (getXPlayerCenter() > item.getXItem() && getXPlayerCenter() < item.getXItem() + item.getSsItem().getWidth()
				&& getYPlayerCenter() > item.getYItem()
				&& getYPlayerCenter() < item.getYItem() + item.getSsItem().getHeight()) {
			return true;
		} else {
			return false;
		}
	}

	// 아이템 획득 종류 확인
	public void getItem() {
		for (int i = 0; i < items.size(); i++) {
			if (items.get(i).isDrop()) {
				if (nearItemCheck(items.get(i))) {
					items.get(i).setDrop(false);
					// Gubun String이 "bomb" 일때
					int luck = (int) (Math.random() * 2);

					if (items.get(i).getSsItem().getGubun() == "bomb") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {
							bombCount += 1;
							labomb.setText(Integer.toString(bombCount));
						} else if (luck == 0) {
							bombCount -= 1;
							labomb.setText(Integer.toString(bombCount));
						} // Gubun String이 "Power" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Power") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							powerNum+=2;
							lapower.setText(Integer.toString(powerNum));
								
						}
						else if(luck == 0) {
							powerNum--;
							lapower.setText(Integer.toString(powerNum));
							
						}
						// Gubun String이 "Speed" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Speed") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							moveSpeed += 3;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));

						}
						else if ( luck == 0) {
							moveSpeed --;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));
							
						}
					}
					else if (items.get(i).getSsItem().getGubun() == "AttackSpeed") {
						if (luck == 1) {

							attackspeedNum +=2;
							laattackspeed.setText(Integer.toString(attackspeedNum));

						}
						else if ( luck == 0) {
							attackspeedNum --;
							laattackspeed.setText(Integer.toString(attackspeedNum));
							
						}
					}
					System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
					getApp().remove(items.get(i).getSsItem());
					getApp().repaint();

				}
			}

		}
	}
}
>>>>>>> origin/최낙연

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-14 16:08:29.868
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-14 16:08:29.868
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-14 16:08:32.433
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package player;

import java.awt.Color;
import java.awt.Font;
import java.io.File;
import java.net.Socket;
import java.util.Vector;

import javax.imageio.ImageIO;
import javax.imageio.ImageTranscoder;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.xml.stream.events.StartDocument;

import player.Player;
import sword.SwordControl;
import SpriteSheet.SpriteSheet;
import imgSize.*;
import lombok.Data;
import monster.Monster;
import monster.Worm;

@Data

public class issac extends Player {
	private final static String TAG = "issac: ";
	private issac issac = this;
	private SpriteSheet ssHead, ssBody;
	private SpriteSheet ssTotal;
	private Vector<SpriteSheet> ssLife;
	private SwordControl swordControl;
	private Worm worm;
	private Vector<Monster> monsters;
	private Vector<wall> walls;
	private Vector<Item> items;
	private int xPlusBody = 7, yPlusBody = 30;
	private int yTotalSize;
	private int item1Count = 0;
	private int item2Count = 0;
	private int item3Count = 0;
	private int item4Count = 0;
	private int moveSpeed = 10;
	// 상하 좌우 이동 모션
	// 개수 및 수치 표시용 레이블 + 변수 선언 및 초기화
	private JLabel labomb;
	private JLabel laspeed;
	private JLabel lapower;
	private JLabel laattackspeed;
	private int bombCount = 0;
	private int speedNum = 11;
	private int powerNum = 1;
	private int attackspeedNum = 1;
	public issac(JFrame app, Vector<Monster> monsters ,  Vector<wall> walls, Vector<Item> items) {
		super(app);
		System.out.println(TAG + "make issac");
		init(monsters ,walls, items);
		setting();
		batch();

	}

	public void init(Vector<Monster> monsters ,Vector<wall> walls, Vector<Item> items) {
		this.walls = walls;
		this.items = items;
		this.monsters = monsters;
		ssHead = new SpriteSheet("issac/issac.png", "issacssHead", 0, 0, issacSize.issacHEADWIDTH,
				issacSize.issacHEADHEIGHT);
		ssBody = new SpriteSheet("issac/issac.png", "issacBody", 0, (issacSize.issacHEADHEIGHT + Gap.ROWGAP),
				issacSize.issacBODYWIDTH, issacSize.issacBODYHEIGHT);
		ssTotal = new SpriteSheet("issac/issac.png", "issacsBody", 0, yTotalSize, issacSize.issacTOTALWIDTH,
				issacSize.issacTOTALHEIGHT);
		yTotalSize = issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 4 + Gap.ROWGAP * 5;
		// 레이블 초기화
		labomb = new JLabel(Integer.toString(bombCount));
		laspeed = new JLabel(Integer.toString(speedNum - moveSpeed));
		lapower = new JLabel(Integer.toString(powerNum));
		laattackspeed = new JLabel(Integer.toString(attackspeedNum));
		ssLife = new Vector<SpriteSheet>();
		for (int i = 0; i < getLife(); i++) {
			this.ssLife.add(i,
					new SpriteSheet("issac/life.png", "life", 0, 0, Lifesize.LIFEWIDTH, Lifesize.LIFEHEIGHT));
		}
		for (int i = (int) getLife(); i < getMaxlife(); i++) {
			this.ssLife.add(new SpriteSheet("issac/life.png", "life", Lifesize.LIFEWIDTH * 2, 0, Lifesize.LIFEWIDTH,
					Lifesize.LIFEHEIGHT));
		}
	}

	public void setting() {
		setViewDirect(ViewDirect.DOWN);
		setXPlayer(480);
		setYPlayer(430);
		setAttackDamge(1);
		setLife(3);
		setXPlayerCenter(getXPlayer() + issacSize.issacHEADWIDTH / 2);
		setYPlayerCenter(getYPlayer() + issacSize.issacHEADHEIGHT);
		ssHead.drawObj(getXPlayer(), getYPlayer());
		ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
		// 폭탄 레이블 설정
		labomb.setSize(30, 30);
		labomb.setLocation(65, 50);
		labomb.setFont(new Font("바탕", Font.ITALIC, 25));
		labomb.setForeground(Color.WHITE);
		// 속도 레이블 설정
		lapower.setSize(30, 30);
		lapower.setLocation(65, 85);
		lapower.setFont(new Font("바탕", Font.ITALIC, 25));
		lapower.setForeground(Color.WHITE);
		// 속도 레이블 설정
		laspeed.setSize(40, 30);
		laspeed.setLocation(65, 120);
		laspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laspeed.setForeground(Color.WHITE);
		// 공속 레이블 설정
		laattackspeed.setSize(40,30);
		laattackspeed.setLocation(65, 155);
		laattackspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laattackspeed.setForeground(Color.WHITE);
		
		for (int i = 0; i < getMaxlife(); i++) {
			if (i <= getLife()) {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			} else {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			}

		}
	}

	public void batch() {
		getApp().add(ssHead, 0);
		getApp().add(ssBody, 1);
		// 폭탄 파워 속도 레이블 추가
		getApp().add(labomb);
		getApp().add(lapower);
		getApp().add(laspeed);
		getApp().add(laattackspeed);
		swordControl = new SwordControl(getApp());
		for (int i = 0; i < getMaxlife(); i++) {
			getApp().add(ssLife.get(i), 1);
		}
	}

	// 상하 좌우 이동 모션
	@Override
	public void moveRight() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isRight() == false) {
					setRight(true);
					setViewDirect(ViewDirect.RIGHT);
					while (isRight()) {
						if (getXPlayer() + issacSize.issacBODYWIDTH > 810) { // 벽이상 움직임 제한
							setRight(false);
							refreshDirect();
							break;
						}
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						setXPlayer(getXPlayer()+1);
						setXPlayerCenter(getXPlayerCenter()+1);
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall()
										&& getXPlayerCenter() < walls.get(i).getXwall() + RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setRight(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveLeft() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isLeft() == false) {
					setLeft(true);
					setViewDirect(ViewDirect.LEFT);
					while (isLeft()) {
						if (getXPlayer() < 130) {
							setLeft(false);
							refreshDirect();
							break;
						}
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {

								if (getXPlayerCenter() > walls.get(i).getXwall()
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setLeft(false);
							refreshDirect();
							break;
						}
						// 돌 충돌 체크 끝
						getItem();
						setXPlayer(getXPlayer() - 1);
						setXPlayerCenter(getXPlayerCenter() - 1);
						moveMotion();
						try {

							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveDown() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isDown() == false) {
					setDown(true);
					setViewDirect(ViewDirect.DOWN);
					while (isDown()) {
						if (getYPlayer() > 440) {
							setDown(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() + (issacSize.issacHEADHEIGHT - yPlusBody) + 5 > walls
												.get(i).getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveUp() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isUp() == false) {
					setUp(true);
					setViewDirect(ViewDirect.UP);
					while (isUp()) {
						if(getYPlayer()<100) {
							setUp(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer()-1);
						setYPlayerCenter(getYPlayerCenter()-1);
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() > walls.get(i).getYwall() && getYPlayerCenter()
												+ (issacSize.issacBODYHEIGHT - yPlusBody) < walls.get(i).getYwall()
														+ RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() - 1);
						setYPlayerCenter(getYPlayerCenter() - 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// // 가져올
																											// 기준이
							// 되는 X좌표가
							// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// // 않게하기위해 사용합니다.
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_down.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
								}
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_left.png"))
										swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
								}
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_up.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
								}
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_right.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
								}
=======
						}	
=======
						}
>>>>>>> origin/최낙연
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override // Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// 가져올 기준이
																											// 되는 X좌표가
																											// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// 않게하기위해 사용합니다.
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer()+xPlusBody, getYPlayer()+yPlusBody);
>>>>>>> origin/최낙연
=======
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
>>>>>>> origin/최낙연
								motion += 1;
							}
						}
						try {
<<<<<<< HEAD
							Thread.sleep(15);
=======
							Thread.sleep(40);
>>>>>>> origin/최낙연
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
<<<<<<< HEAD
<<<<<<< HEAD

			}
		}).start();
	}

	public synchronized void attackMotion() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isPlayerAttack() == false) {
					setPlayerAttack(true);
					if (isPlayerAttack()) {
						int imgxlocation = 1;
						int imgylocation = 0;
						while (true) {
							setPlayerAttacking(true);
							if (getViewDirect() == ViewDirect.DOWN) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setXPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - (SwordMotionSize.IMGHEIGHT)
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_down.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() + 25);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.UP) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword()
										.setXPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.IMGHEIGHT - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_up.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() - 50);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.LEFT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos((SwordMotionSize.IMGHEIGHT) - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setUrl("sword/sword_left.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 60, getYPlayer() - 10);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.RIGHT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordMotionSize.IMGHEIGHT
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword()
										.setYPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setUrl("sword/sword_right.png");
								swordControl.getSsSword().drawObj(getXPlayer() + 20, getYPlayer() - 10);
								imgylocation++;
							}
							try {
								Thread.sleep(20);
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
				}
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	public void reDrawLife() {
		double currentLife = getLife();
		for (int i = 0; i < getMaxlife(); i++) {
			if (currentLife >= 1) {
				ssLife.get(i).setXPos(0);
				currentLife -= 1;
			} else if (currentLife > 0 && currentLife < 1) {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH + Gap.COLUMGAP);
				currentLife -= 0.5;
			} else {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH * 2 + Gap.COLUMGAP * 2);
			}

		}
	}

	public void attack() {
	}
}
=======
				
=======

>>>>>>> origin/최낙연
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	// 주변 아이템 여부 체크
	public boolean nearItemCheck(Item item) {
		if (getXPlayerCenter() > item.getXItem() && getXPlayerCenter() < item.getXItem() + item.getSsItem().getWidth()
				&& getYPlayerCenter() > item.getYItem()
				&& getYPlayerCenter() < item.getYItem() + item.getSsItem().getHeight()) {
			return true;
		} else {
			return false;
		}
	}

	// 아이템 획득 종류 확인
	public void getItem() {
		for (int i = 0; i < items.size(); i++) {
			if (items.get(i).isDrop()) {
				if (nearItemCheck(items.get(i))) {
					items.get(i).setDrop(false);
					// Gubun String이 "bomb" 일때
					int luck = (int) (Math.random() * 2);

					if (items.get(i).getSsItem().getGubun() == "bomb") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {
							bombCount += 1;
							labomb.setText(Integer.toString(bombCount));
						} else if (luck == 0) {
							bombCount -= 1;
							labomb.setText(Integer.toString(bombCount));
						} // Gubun String이 "Power" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Power") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							powerNum+=2;
							lapower.setText(Integer.toString(powerNum));
								
						}
						else if(luck == 0) {
							powerNum--;
							lapower.setText(Integer.toString(powerNum));
							
						}
						// Gubun String이 "Speed" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Speed") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							moveSpeed += 3;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));

						}
						else if ( luck == 0) {
							moveSpeed --;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));
							
						}
					}
					else if (items.get(i).getSsItem().getGubun() == "AttackSpeed") {
						if (luck == 1) {

							attackspeedNum +=2;
							laattackspeed.setText(Integer.toString(attackspeedNum));

						}
						else if ( luck == 0) {
							attackspeedNum --;
							laattackspeed.setText(Integer.toString(attackspeedNum));
							
						}
					}
					System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
					getApp().remove(items.get(i).getSsItem());
					getApp().repaint();

				}
			}

		}
	}
}
>>>>>>> origin/최낙연

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-14 16:08:32.434
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-14 16:08:32.434
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-14 16:08:33.886
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package player;

import java.awt.Color;
import java.awt.Font;
import java.io.File;
import java.net.Socket;
import java.util.Vector;

import javax.imageio.ImageIO;
import javax.imageio.ImageTranscoder;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.xml.stream.events.StartDocument;

import player.Player;
import sword.SwordControl;
import SpriteSheet.SpriteSheet;
import imgSize.*;
import lombok.Data;
import monster.Monster;
import monster.Worm;

@Data

public class issac extends Player {
	private final static String TAG = "issac: ";
	private issac issac = this;
	private SpriteSheet ssHead, ssBody;
	private SpriteSheet ssTotal;
	private Vector<SpriteSheet> ssLife;
	private SwordControl swordControl;
	private Worm worm;
	private Vector<Monster> monsters;
	private Vector<wall> walls;
	private Vector<Item> items;
	private int xPlusBody = 7, yPlusBody = 30;
	private int yTotalSize;
	private int item1Count = 0;
	private int item2Count = 0;
	private int item3Count = 0;
	private int item4Count = 0;
	private int moveSpeed = 10;
	// 상하 좌우 이동 모션
	// 개수 및 수치 표시용 레이블 + 변수 선언 및 초기화
	private JLabel labomb;
	private JLabel laspeed;
	private JLabel lapower;
	private JLabel laattackspeed;
	private int bombCount = 0;
	private int speedNum = 11;
	private int powerNum = 1;
	private int attackspeedNum = 1;
	public issac(JFrame app, Vector<Monster> monsters ,  Vector<wall> walls, Vector<Item> items) {
		super(app);
		System.out.println(TAG + "make issac");
		init(monsters ,walls, items);
		setting();
		batch();

	}

	public void init(Vector<Monster> monsters ,Vector<wall> walls, Vector<Item> items) {
		this.walls = walls;
		this.items = items;
		this.monsters = monsters;
		ssHead = new SpriteSheet("issac/issac.png", "issacssHead", 0, 0, issacSize.issacHEADWIDTH,
				issacSize.issacHEADHEIGHT);
		ssBody = new SpriteSheet("issac/issac.png", "issacBody", 0, (issacSize.issacHEADHEIGHT + Gap.ROWGAP),
				issacSize.issacBODYWIDTH, issacSize.issacBODYHEIGHT);
		ssTotal = new SpriteSheet("issac/issac.png", "issacsBody", 0, yTotalSize, issacSize.issacTOTALWIDTH,
				issacSize.issacTOTALHEIGHT);
		yTotalSize = issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 4 + Gap.ROWGAP * 5;
		// 레이블 초기화
		labomb = new JLabel(Integer.toString(bombCount));
		laspeed = new JLabel(Integer.toString(speedNum - moveSpeed));
		lapower = new JLabel(Integer.toString(powerNum));
		laattackspeed = new JLabel(Integer.toString(attackspeedNum));
		ssLife = new Vector<SpriteSheet>();
		for (int i = 0; i < getLife(); i++) {
			this.ssLife.add(i,
					new SpriteSheet("issac/life.png", "life", 0, 0, Lifesize.LIFEWIDTH, Lifesize.LIFEHEIGHT));
		}
		for (int i = (int) getLife(); i < getMaxlife(); i++) {
			this.ssLife.add(new SpriteSheet("issac/life.png", "life", Lifesize.LIFEWIDTH * 2, 0, Lifesize.LIFEWIDTH,
					Lifesize.LIFEHEIGHT));
		}
	}

	public void setting() {
		setViewDirect(ViewDirect.DOWN);
		setXPlayer(480);
		setYPlayer(430);
		setAttackDamge(1);
		setLife(3);
		setXPlayerCenter(getXPlayer() + issacSize.issacHEADWIDTH / 2);
		setYPlayerCenter(getYPlayer() + issacSize.issacHEADHEIGHT);
		ssHead.drawObj(getXPlayer(), getYPlayer());
		ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
		// 폭탄 레이블 설정
		labomb.setSize(30, 30);
		labomb.setLocation(65, 50);
		labomb.setFont(new Font("바탕", Font.ITALIC, 25));
		labomb.setForeground(Color.WHITE);
		// 속도 레이블 설정
		lapower.setSize(30, 30);
		lapower.setLocation(65, 85);
		lapower.setFont(new Font("바탕", Font.ITALIC, 25));
		lapower.setForeground(Color.WHITE);
		// 속도 레이블 설정
		laspeed.setSize(40, 30);
		laspeed.setLocation(65, 120);
		laspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laspeed.setForeground(Color.WHITE);
		// 공속 레이블 설정
		laattackspeed.setSize(40,30);
		laattackspeed.setLocation(65, 155);
		laattackspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laattackspeed.setForeground(Color.WHITE);
		
		for (int i = 0; i < getMaxlife(); i++) {
			if (i <= getLife()) {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			} else {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			}

		}
	}

	public void batch() {
		getApp().add(ssHead, 0);
		getApp().add(ssBody, 1);
		// 폭탄 파워 속도 레이블 추가
		getApp().add(labomb);
		getApp().add(lapower);
		getApp().add(laspeed);
		getApp().add(laattackspeed);
		swordControl = new SwordControl(getApp());
		for (int i = 0; i < getMaxlife(); i++) {
			getApp().add(ssLife.get(i), 1);
		}
	}

	// 상하 좌우 이동 모션
	@Override
	public void moveRight() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isRight() == false) {
					setRight(true);
					setViewDirect(ViewDirect.RIGHT);
					while (isRight()) {
						if (getXPlayer() + issacSize.issacBODYWIDTH > 810) { // 벽이상 움직임 제한
							setRight(false);
							refreshDirect();
							break;
						}
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						setXPlayer(getXPlayer()+1);
						setXPlayerCenter(getXPlayerCenter()+1);
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall()
										&& getXPlayerCenter() < walls.get(i).getXwall() + RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setRight(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveLeft() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isLeft() == false) {
					setLeft(true);
					setViewDirect(ViewDirect.LEFT);
					while (isLeft()) {
						if (getXPlayer() < 130) {
							setLeft(false);
							refreshDirect();
							break;
						}
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {

								if (getXPlayerCenter() > walls.get(i).getXwall()
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setLeft(false);
							refreshDirect();
							break;
						}
						// 돌 충돌 체크 끝
						getItem();
						setXPlayer(getXPlayer() - 1);
						setXPlayerCenter(getXPlayerCenter() - 1);
						moveMotion();
						try {

							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveDown() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isDown() == false) {
					setDown(true);
					setViewDirect(ViewDirect.DOWN);
					while (isDown()) {
						if (getYPlayer() > 440) {
							setDown(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() + (issacSize.issacHEADHEIGHT - yPlusBody) + 5 > walls
												.get(i).getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveUp() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isUp() == false) {
					setUp(true);
					setViewDirect(ViewDirect.UP);
					while (isUp()) {
						if(getYPlayer()<100) {
							setUp(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer()-1);
						setYPlayerCenter(getYPlayerCenter()-1);
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() > walls.get(i).getYwall() && getYPlayerCenter()
												+ (issacSize.issacBODYHEIGHT - yPlusBody) < walls.get(i).getYwall()
														+ RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() - 1);
						setYPlayerCenter(getYPlayerCenter() - 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// // 가져올
																											// 기준이
							// 되는 X좌표가
							// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// // 않게하기위해 사용합니다.
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_down.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
								}
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_left.png"))
										swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
								}
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_up.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
								}
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_right.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
								}
=======
						}	
=======
						}
>>>>>>> origin/최낙연
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override // Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// 가져올 기준이
																											// 되는 X좌표가
																											// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// 않게하기위해 사용합니다.
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer()+xPlusBody, getYPlayer()+yPlusBody);
>>>>>>> origin/최낙연
=======
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
>>>>>>> origin/최낙연
								motion += 1;
							}
						}
						try {
<<<<<<< HEAD
							Thread.sleep(15);
=======
							Thread.sleep(40);
>>>>>>> origin/최낙연
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
<<<<<<< HEAD
<<<<<<< HEAD

			}
		}).start();
	}

	public synchronized void attackMotion() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isPlayerAttack() == false) {
					setPlayerAttack(true);
					if (isPlayerAttack()) {
						int imgxlocation = 1;
						int imgylocation = 0;
						while (true) {
							setPlayerAttacking(true);
							if (getViewDirect() == ViewDirect.DOWN) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setXPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - (SwordMotionSize.IMGHEIGHT)
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_down.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() + 25);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.UP) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword()
										.setXPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.IMGHEIGHT - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_up.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() - 50);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.LEFT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos((SwordMotionSize.IMGHEIGHT) - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setUrl("sword/sword_left.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 60, getYPlayer() - 10);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.RIGHT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordMotionSize.IMGHEIGHT
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword()
										.setYPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setUrl("sword/sword_right.png");
								swordControl.getSsSword().drawObj(getXPlayer() + 20, getYPlayer() - 10);
								imgylocation++;
							}
							try {
								Thread.sleep(20);
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
				}
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	public void reDrawLife() {
		double currentLife = getLife();
		for (int i = 0; i < getMaxlife(); i++) {
			if (currentLife >= 1) {
				ssLife.get(i).setXPos(0);
				currentLife -= 1;
			} else if (currentLife > 0 && currentLife < 1) {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH + Gap.COLUMGAP);
				currentLife -= 0.5;
			} else {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH * 2 + Gap.COLUMGAP * 2);
			}

		}
	}

	public void attack() {
	}
}
=======
				
=======

>>>>>>> origin/최낙연
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	// 주변 아이템 여부 체크
	public boolean nearItemCheck(Item item) {
		if (getXPlayerCenter() > item.getXItem() && getXPlayerCenter() < item.getXItem() + item.getSsItem().getWidth()
				&& getYPlayerCenter() > item.getYItem()
				&& getYPlayerCenter() < item.getYItem() + item.getSsItem().getHeight()) {
			return true;
		} else {
			return false;
		}
	}

	// 아이템 획득 종류 확인
	public void getItem() {
		for (int i = 0; i < items.size(); i++) {
			if (items.get(i).isDrop()) {
				if (nearItemCheck(items.get(i))) {
					items.get(i).setDrop(false);
					// Gubun String이 "bomb" 일때
					int luck = (int) (Math.random() * 2);

					if (items.get(i).getSsItem().getGubun() == "bomb") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {
							bombCount += 1;
							labomb.setText(Integer.toString(bombCount));
						} else if (luck == 0) {
							bombCount -= 1;
							labomb.setText(Integer.toString(bombCount));
						} // Gubun String이 "Power" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Power") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							powerNum+=2;
							lapower.setText(Integer.toString(powerNum));
								
						}
						else if(luck == 0) {
							powerNum--;
							lapower.setText(Integer.toString(powerNum));
							
						}
						// Gubun String이 "Speed" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Speed") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							moveSpeed += 3;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));

						}
						else if ( luck == 0) {
							moveSpeed --;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));
							
						}
					}
					else if (items.get(i).getSsItem().getGubun() == "AttackSpeed") {
						if (luck == 1) {

							attackspeedNum +=2;
							laattackspeed.setText(Integer.toString(attackspeedNum));

						}
						else if ( luck == 0) {
							attackspeedNum --;
							laattackspeed.setText(Integer.toString(attackspeedNum));
							
						}
					}
					System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
					getApp().remove(items.get(i).getSsItem());
					getApp().repaint();

				}
			}

		}
	}
}
>>>>>>> origin/최낙연

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-14 16:08:33.887
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-14 16:08:33.887
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-14 16:08:36.059
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package player;

import java.awt.Color;
import java.awt.Font;
import java.io.File;
import java.net.Socket;
import java.util.Vector;

import javax.imageio.ImageIO;
import javax.imageio.ImageTranscoder;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.xml.stream.events.StartDocument;

import player.Player;
import sword.SwordControl;
import SpriteSheet.SpriteSheet;
import imgSize.*;
import lombok.Data;
import monster.Monster;
import monster.Worm;

@Data

public class issac extends Player {
	private final static String TAG = "issac: ";
	private issac issac = this;
	private SpriteSheet ssHead, ssBody;
	private SpriteSheet ssTotal;
	private Vector<SpriteSheet> ssLife;
	private SwordControl swordControl;
	private Worm worm;
	private Vector<Monster> monsters;
	private Vector<wall> walls;
	private Vector<Item> items;
	private int xPlusBody = 7, yPlusBody = 30;
	private int yTotalSize;
	private int item1Count = 0;
	private int item2Count = 0;
	private int item3Count = 0;
	private int item4Count = 0;
	private int moveSpeed = 10;
	// 상하 좌우 이동 모션
	// 개수 및 수치 표시용 레이블 + 변수 선언 및 초기화
	private JLabel labomb;
	private JLabel laspeed;
	private JLabel lapower;
	private JLabel laattackspeed;
	private int bombCount = 0;
	private int speedNum = 11;
	private int powerNum = 1;
	private int attackspeedNum = 1;
	public issac(JFrame app, Vector<Monster> monsters ,  Vector<wall> walls, Vector<Item> items) {
		super(app);
		System.out.println(TAG + "make issac");
		init(monsters ,walls, items);
		setting();
		batch();

	}

	public void init(Vector<Monster> monsters ,Vector<wall> walls, Vector<Item> items) {
		this.walls = walls;
		this.items = items;
		this.monsters = monsters;
		ssHead = new SpriteSheet("issac/issac.png", "issacssHead", 0, 0, issacSize.issacHEADWIDTH,
				issacSize.issacHEADHEIGHT);
		ssBody = new SpriteSheet("issac/issac.png", "issacBody", 0, (issacSize.issacHEADHEIGHT + Gap.ROWGAP),
				issacSize.issacBODYWIDTH, issacSize.issacBODYHEIGHT);
		ssTotal = new SpriteSheet("issac/issac.png", "issacsBody", 0, yTotalSize, issacSize.issacTOTALWIDTH,
				issacSize.issacTOTALHEIGHT);
		yTotalSize = issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 4 + Gap.ROWGAP * 5;
		// 레이블 초기화
		labomb = new JLabel(Integer.toString(bombCount));
		laspeed = new JLabel(Integer.toString(speedNum - moveSpeed));
		lapower = new JLabel(Integer.toString(powerNum));
		laattackspeed = new JLabel(Integer.toString(attackspeedNum));
		ssLife = new Vector<SpriteSheet>();
		for (int i = 0; i < getLife(); i++) {
			this.ssLife.add(i,
					new SpriteSheet("issac/life.png", "life", 0, 0, Lifesize.LIFEWIDTH, Lifesize.LIFEHEIGHT));
		}
		for (int i = (int) getLife(); i < getMaxlife(); i++) {
			this.ssLife.add(new SpriteSheet("issac/life.png", "life", Lifesize.LIFEWIDTH * 2, 0, Lifesize.LIFEWIDTH,
					Lifesize.LIFEHEIGHT));
		}
	}

	public void setting() {
		setViewDirect(ViewDirect.DOWN);
		setXPlayer(480);
		setYPlayer(430);
		setAttackDamge(1);
		setLife(3);
		setXPlayerCenter(getXPlayer() + issacSize.issacHEADWIDTH / 2);
		setYPlayerCenter(getYPlayer() + issacSize.issacHEADHEIGHT);
		ssHead.drawObj(getXPlayer(), getYPlayer());
		ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
		// 폭탄 레이블 설정
		labomb.setSize(30, 30);
		labomb.setLocation(65, 50);
		labomb.setFont(new Font("바탕", Font.ITALIC, 25));
		labomb.setForeground(Color.WHITE);
		// 속도 레이블 설정
		lapower.setSize(30, 30);
		lapower.setLocation(65, 85);
		lapower.setFont(new Font("바탕", Font.ITALIC, 25));
		lapower.setForeground(Color.WHITE);
		// 속도 레이블 설정
		laspeed.setSize(40, 30);
		laspeed.setLocation(65, 120);
		laspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laspeed.setForeground(Color.WHITE);
		// 공속 레이블 설정
		laattackspeed.setSize(40,30);
		laattackspeed.setLocation(65, 155);
		laattackspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laattackspeed.setForeground(Color.WHITE);
		
		for (int i = 0; i < getMaxlife(); i++) {
			if (i <= getLife()) {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			} else {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			}

		}
	}

	public void batch() {
		getApp().add(ssHead, 0);
		getApp().add(ssBody, 1);
		// 폭탄 파워 속도 레이블 추가
		getApp().add(labomb);
		getApp().add(lapower);
		getApp().add(laspeed);
		getApp().add(laattackspeed);
		swordControl = new SwordControl(getApp());
		for (int i = 0; i < getMaxlife(); i++) {
			getApp().add(ssLife.get(i), 1);
		}
	}

	// 상하 좌우 이동 모션
	@Override
	public void moveRight() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isRight() == false) {
					setRight(true);
					setViewDirect(ViewDirect.RIGHT);
					while (isRight()) {
						if (getXPlayer() + issacSize.issacBODYWIDTH > 810) { // 벽이상 움직임 제한
							setRight(false);
							refreshDirect();
							break;
						}
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						setXPlayer(getXPlayer()+1);
						setXPlayerCenter(getXPlayerCenter()+1);
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall()
										&& getXPlayerCenter() < walls.get(i).getXwall() + RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setRight(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveLeft() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isLeft() == false) {
					setLeft(true);
					setViewDirect(ViewDirect.LEFT);
					while (isLeft()) {
						if (getXPlayer() < 130) {
							setLeft(false);
							refreshDirect();
							break;
						}
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {

								if (getXPlayerCenter() > walls.get(i).getXwall()
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setLeft(false);
							refreshDirect();
							break;
						}
						// 돌 충돌 체크 끝
						getItem();
						setXPlayer(getXPlayer() - 1);
						setXPlayerCenter(getXPlayerCenter() - 1);
						moveMotion();
						try {

							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveDown() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isDown() == false) {
					setDown(true);
					setViewDirect(ViewDirect.DOWN);
					while (isDown()) {
						if (getYPlayer() > 440) {
							setDown(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() + (issacSize.issacHEADHEIGHT - yPlusBody) + 5 > walls
												.get(i).getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveUp() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isUp() == false) {
					setUp(true);
					setViewDirect(ViewDirect.UP);
					while (isUp()) {
						if(getYPlayer()<100) {
							setUp(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer()-1);
						setYPlayerCenter(getYPlayerCenter()-1);
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() > walls.get(i).getYwall() && getYPlayerCenter()
												+ (issacSize.issacBODYHEIGHT - yPlusBody) < walls.get(i).getYwall()
														+ RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() - 1);
						setYPlayerCenter(getYPlayerCenter() - 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// // 가져올
																											// 기준이
							// 되는 X좌표가
							// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// // 않게하기위해 사용합니다.
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_down.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
								}
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_left.png"))
										swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
								}
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_up.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
								}
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_right.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
								}
=======
						}	
=======
						}
>>>>>>> origin/최낙연
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override // Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// 가져올 기준이
																											// 되는 X좌표가
																											// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// 않게하기위해 사용합니다.
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer()+xPlusBody, getYPlayer()+yPlusBody);
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
>>>>>>> origin/최낙연
								motion += 1;
							}
						}
						try {
<<<<<<< HEAD
							Thread.sleep(15);
=======
							Thread.sleep(40);
>>>>>>> origin/최낙연
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
<<<<<<< HEAD
<<<<<<< HEAD

			}
		}).start();
	}

	public synchronized void attackMotion() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isPlayerAttack() == false) {
					setPlayerAttack(true);
					if (isPlayerAttack()) {
						int imgxlocation = 1;
						int imgylocation = 0;
						while (true) {
							setPlayerAttacking(true);
							if (getViewDirect() == ViewDirect.DOWN) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setXPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - (SwordMotionSize.IMGHEIGHT)
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_down.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() + 25);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.UP) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword()
										.setXPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.IMGHEIGHT - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_up.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() - 50);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.LEFT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos((SwordMotionSize.IMGHEIGHT) - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setUrl("sword/sword_left.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 60, getYPlayer() - 10);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.RIGHT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordMotionSize.IMGHEIGHT
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword()
										.setYPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setUrl("sword/sword_right.png");
								swordControl.getSsSword().drawObj(getXPlayer() + 20, getYPlayer() - 10);
								imgylocation++;
							}
							try {
								Thread.sleep(20);
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
				}
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	public void reDrawLife() {
		double currentLife = getLife();
		for (int i = 0; i < getMaxlife(); i++) {
			if (currentLife >= 1) {
				ssLife.get(i).setXPos(0);
				currentLife -= 1;
			} else if (currentLife > 0 && currentLife < 1) {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH + Gap.COLUMGAP);
				currentLife -= 0.5;
			} else {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH * 2 + Gap.COLUMGAP * 2);
			}

		}
	}

	public void attack() {
	}
}
=======
				
=======

>>>>>>> origin/최낙연
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	// 주변 아이템 여부 체크
	public boolean nearItemCheck(Item item) {
		if (getXPlayerCenter() > item.getXItem() && getXPlayerCenter() < item.getXItem() + item.getSsItem().getWidth()
				&& getYPlayerCenter() > item.getYItem()
				&& getYPlayerCenter() < item.getYItem() + item.getSsItem().getHeight()) {
			return true;
		} else {
			return false;
		}
	}

	// 아이템 획득 종류 확인
	public void getItem() {
		for (int i = 0; i < items.size(); i++) {
			if (items.get(i).isDrop()) {
				if (nearItemCheck(items.get(i))) {
					items.get(i).setDrop(false);
					// Gubun String이 "bomb" 일때
					int luck = (int) (Math.random() * 2);

					if (items.get(i).getSsItem().getGubun() == "bomb") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {
							bombCount += 1;
							labomb.setText(Integer.toString(bombCount));
						} else if (luck == 0) {
							bombCount -= 1;
							labomb.setText(Integer.toString(bombCount));
						} // Gubun String이 "Power" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Power") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							powerNum+=2;
							lapower.setText(Integer.toString(powerNum));
								
						}
						else if(luck == 0) {
							powerNum--;
							lapower.setText(Integer.toString(powerNum));
							
						}
						// Gubun String이 "Speed" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Speed") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							moveSpeed += 3;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));

						}
						else if ( luck == 0) {
							moveSpeed --;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));
							
						}
					}
					else if (items.get(i).getSsItem().getGubun() == "AttackSpeed") {
						if (luck == 1) {

							attackspeedNum +=2;
							laattackspeed.setText(Integer.toString(attackspeedNum));

						}
						else if ( luck == 0) {
							attackspeedNum --;
							laattackspeed.setText(Integer.toString(attackspeedNum));
							
						}
					}
					System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
					getApp().remove(items.get(i).getSsItem());
					getApp().repaint();

				}
			}

		}
	}
}
>>>>>>> origin/최낙연

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-14 16:08:36.060
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-14 16:08:36.060
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-14 16:08:36.484
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package player;

import java.awt.Color;
import java.awt.Font;
import java.io.File;
import java.net.Socket;
import java.util.Vector;

import javax.imageio.ImageIO;
import javax.imageio.ImageTranscoder;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.xml.stream.events.StartDocument;

import player.Player;
import sword.SwordControl;
import SpriteSheet.SpriteSheet;
import imgSize.*;
import lombok.Data;
import monster.Monster;
import monster.Worm;

@Data

public class issac extends Player {
	private final static String TAG = "issac: ";
	private issac issac = this;
	private SpriteSheet ssHead, ssBody;
	private SpriteSheet ssTotal;
	private Vector<SpriteSheet> ssLife;
	private SwordControl swordControl;
	private Worm worm;
	private Vector<Monster> monsters;
	private Vector<wall> walls;
	private Vector<Item> items;
	private int xPlusBody = 7, yPlusBody = 30;
	private int yTotalSize;
	private int item1Count = 0;
	private int item2Count = 0;
	private int item3Count = 0;
	private int item4Count = 0;
	private int moveSpeed = 10;
	// 상하 좌우 이동 모션
	// 개수 및 수치 표시용 레이블 + 변수 선언 및 초기화
	private JLabel labomb;
	private JLabel laspeed;
	private JLabel lapower;
	private JLabel laattackspeed;
	private int bombCount = 0;
	private int speedNum = 11;
	private int powerNum = 1;
	private int attackspeedNum = 1;
	public issac(JFrame app, Vector<Monster> monsters ,  Vector<wall> walls, Vector<Item> items) {
		super(app);
		System.out.println(TAG + "make issac");
		init(monsters ,walls, items);
		setting();
		batch();

	}

	public void init(Vector<Monster> monsters ,Vector<wall> walls, Vector<Item> items) {
		this.walls = walls;
		this.items = items;
		this.monsters = monsters;
		ssHead = new SpriteSheet("issac/issac.png", "issacssHead", 0, 0, issacSize.issacHEADWIDTH,
				issacSize.issacHEADHEIGHT);
		ssBody = new SpriteSheet("issac/issac.png", "issacBody", 0, (issacSize.issacHEADHEIGHT + Gap.ROWGAP),
				issacSize.issacBODYWIDTH, issacSize.issacBODYHEIGHT);
		ssTotal = new SpriteSheet("issac/issac.png", "issacsBody", 0, yTotalSize, issacSize.issacTOTALWIDTH,
				issacSize.issacTOTALHEIGHT);
		yTotalSize = issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 4 + Gap.ROWGAP * 5;
		// 레이블 초기화
		labomb = new JLabel(Integer.toString(bombCount));
		laspeed = new JLabel(Integer.toString(speedNum - moveSpeed));
		lapower = new JLabel(Integer.toString(powerNum));
		laattackspeed = new JLabel(Integer.toString(attackspeedNum));
		ssLife = new Vector<SpriteSheet>();
		for (int i = 0; i < getLife(); i++) {
			this.ssLife.add(i,
					new SpriteSheet("issac/life.png", "life", 0, 0, Lifesize.LIFEWIDTH, Lifesize.LIFEHEIGHT));
		}
		for (int i = (int) getLife(); i < getMaxlife(); i++) {
			this.ssLife.add(new SpriteSheet("issac/life.png", "life", Lifesize.LIFEWIDTH * 2, 0, Lifesize.LIFEWIDTH,
					Lifesize.LIFEHEIGHT));
		}
	}

	public void setting() {
		setViewDirect(ViewDirect.DOWN);
		setXPlayer(480);
		setYPlayer(430);
		setAttackDamge(1);
		setLife(3);
		setXPlayerCenter(getXPlayer() + issacSize.issacHEADWIDTH / 2);
		setYPlayerCenter(getYPlayer() + issacSize.issacHEADHEIGHT);
		ssHead.drawObj(getXPlayer(), getYPlayer());
		ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
		// 폭탄 레이블 설정
		labomb.setSize(30, 30);
		labomb.setLocation(65, 50);
		labomb.setFont(new Font("바탕", Font.ITALIC, 25));
		labomb.setForeground(Color.WHITE);
		// 속도 레이블 설정
		lapower.setSize(30, 30);
		lapower.setLocation(65, 85);
		lapower.setFont(new Font("바탕", Font.ITALIC, 25));
		lapower.setForeground(Color.WHITE);
		// 속도 레이블 설정
		laspeed.setSize(40, 30);
		laspeed.setLocation(65, 120);
		laspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laspeed.setForeground(Color.WHITE);
		// 공속 레이블 설정
		laattackspeed.setSize(40,30);
		laattackspeed.setLocation(65, 155);
		laattackspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laattackspeed.setForeground(Color.WHITE);
		
		for (int i = 0; i < getMaxlife(); i++) {
			if (i <= getLife()) {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			} else {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			}

		}
	}

	public void batch() {
		getApp().add(ssHead, 0);
		getApp().add(ssBody, 1);
		// 폭탄 파워 속도 레이블 추가
		getApp().add(labomb);
		getApp().add(lapower);
		getApp().add(laspeed);
		getApp().add(laattackspeed);
		swordControl = new SwordControl(getApp());
		for (int i = 0; i < getMaxlife(); i++) {
			getApp().add(ssLife.get(i), 1);
		}
	}

	// 상하 좌우 이동 모션
	@Override
	public void moveRight() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isRight() == false) {
					setRight(true);
					setViewDirect(ViewDirect.RIGHT);
					while (isRight()) {
						if (getXPlayer() + issacSize.issacBODYWIDTH > 810) { // 벽이상 움직임 제한
							setRight(false);
							refreshDirect();
							break;
						}
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						setXPlayer(getXPlayer()+1);
						setXPlayerCenter(getXPlayerCenter()+1);
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall()
										&& getXPlayerCenter() < walls.get(i).getXwall() + RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setRight(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveLeft() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isLeft() == false) {
					setLeft(true);
					setViewDirect(ViewDirect.LEFT);
					while (isLeft()) {
						if (getXPlayer() < 130) {
							setLeft(false);
							refreshDirect();
							break;
						}
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {

								if (getXPlayerCenter() > walls.get(i).getXwall()
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setLeft(false);
							refreshDirect();
							break;
						}
						// 돌 충돌 체크 끝
						getItem();
						setXPlayer(getXPlayer() - 1);
						setXPlayerCenter(getXPlayerCenter() - 1);
						moveMotion();
						try {

							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveDown() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isDown() == false) {
					setDown(true);
					setViewDirect(ViewDirect.DOWN);
					while (isDown()) {
						if (getYPlayer() > 440) {
							setDown(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() + (issacSize.issacHEADHEIGHT - yPlusBody) + 5 > walls
												.get(i).getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveUp() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isUp() == false) {
					setUp(true);
					setViewDirect(ViewDirect.UP);
					while (isUp()) {
						if(getYPlayer()<100) {
							setUp(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer()-1);
						setYPlayerCenter(getYPlayerCenter()-1);
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() > walls.get(i).getYwall() && getYPlayerCenter()
												+ (issacSize.issacBODYHEIGHT - yPlusBody) < walls.get(i).getYwall()
														+ RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() - 1);
						setYPlayerCenter(getYPlayerCenter() - 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// // 가져올
																											// 기준이
							// 되는 X좌표가
							// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// // 않게하기위해 사용합니다.
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_down.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
								}
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_left.png"))
										swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
								}
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_up.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
								}
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_right.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
								}
=======
						}	
=======
						}
>>>>>>> origin/최낙연
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override // Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// 가져올 기준이
																											// 되는 X좌표가
																											// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// 않게하기위해 사용합니다.
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer()+xPlusBody, getYPlayer()+yPlusBody);
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
>>>>>>> origin/최낙연
								motion += 1;
							}
						}
						try {
<<<<<<< HEAD
							Thread.sleep(15);
=======
							Thread.sleep(40);
>>>>>>> origin/최낙연
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
<<<<<<< HEAD
<<<<<<< HEAD

			}
		}).start();
	}

	public synchronized void attackMotion() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isPlayerAttack() == false) {
					setPlayerAttack(true);
					if (isPlayerAttack()) {
						int imgxlocation = 1;
						int imgylocation = 0;
						while (true) {
							setPlayerAttacking(true);
							if (getViewDirect() == ViewDirect.DOWN) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setXPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - (SwordMotionSize.IMGHEIGHT)
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_down.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() + 25);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.UP) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword()
										.setXPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.IMGHEIGHT - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_up.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() - 50);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.LEFT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos((SwordMotionSize.IMGHEIGHT) - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setUrl("sword/sword_left.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 60, getYPlayer() - 10);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.RIGHT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordMotionSize.IMGHEIGHT
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword()
										.setYPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setUrl("sword/sword_right.png");
								swordControl.getSsSword().drawObj(getXPlayer() + 20, getYPlayer() - 10);
								imgylocation++;
							}
							try {
								Thread.sleep(20);
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
				}
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	public void reDrawLife() {
		double currentLife = getLife();
		for (int i = 0; i < getMaxlife(); i++) {
			if (currentLife >= 1) {
				ssLife.get(i).setXPos(0);
				currentLife -= 1;
			} else if (currentLife > 0 && currentLife < 1) {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH + Gap.COLUMGAP);
				currentLife -= 0.5;
			} else {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH * 2 + Gap.COLUMGAP * 2);
			}

		}
	}

	public void attack() {
	}
}
=======
				
=======

>>>>>>> origin/최낙연
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	// 주변 아이템 여부 체크
	public boolean nearItemCheck(Item item) {
		if (getXPlayerCenter() > item.getXItem() && getXPlayerCenter() < item.getXItem() + item.getSsItem().getWidth()
				&& getYPlayerCenter() > item.getYItem()
				&& getYPlayerCenter() < item.getYItem() + item.getSsItem().getHeight()) {
			return true;
		} else {
			return false;
		}
	}

	// 아이템 획득 종류 확인
	public void getItem() {
		for (int i = 0; i < items.size(); i++) {
			if (items.get(i).isDrop()) {
				if (nearItemCheck(items.get(i))) {
					items.get(i).setDrop(false);
					// Gubun String이 "bomb" 일때
					int luck = (int) (Math.random() * 2);

					if (items.get(i).getSsItem().getGubun() == "bomb") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {
							bombCount += 1;
							labomb.setText(Integer.toString(bombCount));
						} else if (luck == 0) {
							bombCount -= 1;
							labomb.setText(Integer.toString(bombCount));
						} // Gubun String이 "Power" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Power") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							powerNum+=2;
							lapower.setText(Integer.toString(powerNum));
								
						}
						else if(luck == 0) {
							powerNum--;
							lapower.setText(Integer.toString(powerNum));
							
						}
						// Gubun String이 "Speed" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Speed") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							moveSpeed += 3;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));

						}
						else if ( luck == 0) {
							moveSpeed --;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));
							
						}
					}
					else if (items.get(i).getSsItem().getGubun() == "AttackSpeed") {
						if (luck == 1) {

							attackspeedNum +=2;
							laattackspeed.setText(Integer.toString(attackspeedNum));

						}
						else if ( luck == 0) {
							attackspeedNum --;
							laattackspeed.setText(Integer.toString(attackspeedNum));
							
						}
					}
					System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
					getApp().remove(items.get(i).getSsItem());
					getApp().repaint();

				}
			}

		}
	}
}
>>>>>>> origin/최낙연

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-14 16:08:36.484
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-14 16:08:36.484
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2291)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-14 16:08:37.634
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package player;

import java.awt.Color;
import java.awt.Font;
import java.io.File;
import java.net.Socket;
import java.util.Vector;

import javax.imageio.ImageIO;
import javax.imageio.ImageTranscoder;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.xml.stream.events.StartDocument;

import player.Player;
import sword.SwordControl;
import SpriteSheet.SpriteSheet;
import imgSize.*;
import lombok.Data;
import monster.Monster;
import monster.Worm;

@Data

public class issac extends Player {
	private final static String TAG = "issac: ";
	private issac issac = this;
	private SpriteSheet ssHead, ssBody;
	private SpriteSheet ssTotal;
	private Vector<SpriteSheet> ssLife;
	private SwordControl swordControl;
	private Worm worm;
	private Vector<Monster> monsters;
	private Vector<wall> walls;
	private Vector<Item> items;
	private int xPlusBody = 7, yPlusBody = 30;
	private int yTotalSize;
	private int item1Count = 0;
	private int item2Count = 0;
	private int item3Count = 0;
	private int item4Count = 0;
	private int moveSpeed = 10;
	// 상하 좌우 이동 모션
	// 개수 및 수치 표시용 레이블 + 변수 선언 및 초기화
	private JLabel labomb;
	private JLabel laspeed;
	private JLabel lapower;
	private JLabel laattackspeed;
	private int bombCount = 0;
	private int speedNum = 11;
	private int powerNum = 1;
	private int attackspeedNum = 1;
	public issac(JFrame app, Vector<Monster> monsters ,  Vector<wall> walls, Vector<Item> items) {
		super(app);
		System.out.println(TAG + "make issac");
		init(monsters ,walls, items);
		setting();
		batch();

	}

	public void init(Vector<Monster> monsters ,Vector<wall> walls, Vector<Item> items) {
		this.walls = walls;
		this.items = items;
		this.monsters = monsters;
		ssHead = new SpriteSheet("issac/issac.png", "issacssHead", 0, 0, issacSize.issacHEADWIDTH,
				issacSize.issacHEADHEIGHT);
		ssBody = new SpriteSheet("issac/issac.png", "issacBody", 0, (issacSize.issacHEADHEIGHT + Gap.ROWGAP),
				issacSize.issacBODYWIDTH, issacSize.issacBODYHEIGHT);
		ssTotal = new SpriteSheet("issac/issac.png", "issacsBody", 0, yTotalSize, issacSize.issacTOTALWIDTH,
				issacSize.issacTOTALHEIGHT);
		yTotalSize = issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 4 + Gap.ROWGAP * 5;
		// 레이블 초기화
		labomb = new JLabel(Integer.toString(bombCount));
		laspeed = new JLabel(Integer.toString(speedNum - moveSpeed));
		lapower = new JLabel(Integer.toString(powerNum));
		laattackspeed = new JLabel(Integer.toString(attackspeedNum));
		ssLife = new Vector<SpriteSheet>();
		for (int i = 0; i < getLife(); i++) {
			this.ssLife.add(i,
					new SpriteSheet("issac/life.png", "life", 0, 0, Lifesize.LIFEWIDTH, Lifesize.LIFEHEIGHT));
		}
		for (int i = (int) getLife(); i < getMaxlife(); i++) {
			this.ssLife.add(new SpriteSheet("issac/life.png", "life", Lifesize.LIFEWIDTH * 2, 0, Lifesize.LIFEWIDTH,
					Lifesize.LIFEHEIGHT));
		}
	}

	public void setting() {
		setViewDirect(ViewDirect.DOWN);
		setXPlayer(480);
		setYPlayer(430);
		setAttackDamge(1);
		setLife(3);
		setXPlayerCenter(getXPlayer() + issacSize.issacHEADWIDTH / 2);
		setYPlayerCenter(getYPlayer() + issacSize.issacHEADHEIGHT);
		ssHead.drawObj(getXPlayer(), getYPlayer());
		ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
		// 폭탄 레이블 설정
		labomb.setSize(30, 30);
		labomb.setLocation(65, 50);
		labomb.setFont(new Font("바탕", Font.ITALIC, 25));
		labomb.setForeground(Color.WHITE);
		// 속도 레이블 설정
		lapower.setSize(30, 30);
		lapower.setLocation(65, 85);
		lapower.setFont(new Font("바탕", Font.ITALIC, 25));
		lapower.setForeground(Color.WHITE);
		// 속도 레이블 설정
		laspeed.setSize(40, 30);
		laspeed.setLocation(65, 120);
		laspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laspeed.setForeground(Color.WHITE);
		// 공속 레이블 설정
		laattackspeed.setSize(40,30);
		laattackspeed.setLocation(65, 155);
		laattackspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laattackspeed.setForeground(Color.WHITE);
		
		for (int i = 0; i < getMaxlife(); i++) {
			if (i <= getLife()) {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			} else {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			}

		}
	}

	public void batch() {
		getApp().add(ssHead, 0);
		getApp().add(ssBody, 1);
		// 폭탄 파워 속도 레이블 추가
		getApp().add(labomb);
		getApp().add(lapower);
		getApp().add(laspeed);
		getApp().add(laattackspeed);
		swordControl = new SwordControl(getApp());
		for (int i = 0; i < getMaxlife(); i++) {
			getApp().add(ssLife.get(i), 1);
		}
	}

	// 상하 좌우 이동 모션
	@Override
	public void moveRight() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isRight() == false) {
					setRight(true);
					setViewDirect(ViewDirect.RIGHT);
					while (isRight()) {
						if (getXPlayer() + issacSize.issacBODYWIDTH > 810) { // 벽이상 움직임 제한
							setRight(false);
							refreshDirect();
							break;
						}
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						setXPlayer(getXPlayer()+1);
						setXPlayerCenter(getXPlayerCenter()+1);
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall()
										&& getXPlayerCenter() < walls.get(i).getXwall() + RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setRight(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveLeft() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isLeft() == false) {
					setLeft(true);
					setViewDirect(ViewDirect.LEFT);
					while (isLeft()) {
						if (getXPlayer() < 130) {
							setLeft(false);
							refreshDirect();
							break;
						}
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {

								if (getXPlayerCenter() > walls.get(i).getXwall()
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setLeft(false);
							refreshDirect();
							break;
						}
						// 돌 충돌 체크 끝
						getItem();
						setXPlayer(getXPlayer() - 1);
						setXPlayerCenter(getXPlayerCenter() - 1);
						moveMotion();
						try {

							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveDown() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isDown() == false) {
					setDown(true);
					setViewDirect(ViewDirect.DOWN);
					while (isDown()) {
						if (getYPlayer() > 440) {
							setDown(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() + (issacSize.issacHEADHEIGHT - yPlusBody) + 5 > walls
												.get(i).getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveUp() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isUp() == false) {
					setUp(true);
					setViewDirect(ViewDirect.UP);
					while (isUp()) {
						if(getYPlayer()<100) {
							setUp(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer()-1);
						setYPlayerCenter(getYPlayerCenter()-1);
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() > walls.get(i).getYwall() && getYPlayerCenter()
												+ (issacSize.issacBODYHEIGHT - yPlusBody) < walls.get(i).getYwall()
														+ RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() - 1);
						setYPlayerCenter(getYPlayerCenter() - 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// // 가져올
																											// 기준이
							// 되는 X좌표가
							// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// // 않게하기위해 사용합니다.
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_down.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
								}
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_left.png"))
										swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
								}
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_up.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
								}
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_right.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
								}
=======
						}	
=======
						}
>>>>>>> origin/최낙연
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override // Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// 가져올 기준이
																											// 되는 X좌표가
																											// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// 않게하기위해 사용합니다.
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer()+xPlusBody, getYPlayer()+yPlusBody);
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						}
						try {
<<<<<<< HEAD
							Thread.sleep(15);
=======
							Thread.sleep(40);
>>>>>>> origin/최낙연
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
<<<<<<< HEAD
<<<<<<< HEAD

			}
		}).start();
	}

	public synchronized void attackMotion() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isPlayerAttack() == false) {
					setPlayerAttack(true);
					if (isPlayerAttack()) {
						int imgxlocation = 1;
						int imgylocation = 0;
						while (true) {
							setPlayerAttacking(true);
							if (getViewDirect() == ViewDirect.DOWN) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setXPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - (SwordMotionSize.IMGHEIGHT)
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_down.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() + 25);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.UP) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword()
										.setXPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.IMGHEIGHT - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_up.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() - 50);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.LEFT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos((SwordMotionSize.IMGHEIGHT) - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setUrl("sword/sword_left.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 60, getYPlayer() - 10);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.RIGHT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordMotionSize.IMGHEIGHT
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword()
										.setYPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setUrl("sword/sword_right.png");
								swordControl.getSsSword().drawObj(getXPlayer() + 20, getYPlayer() - 10);
								imgylocation++;
							}
							try {
								Thread.sleep(20);
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
				}
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	public void reDrawLife() {
		double currentLife = getLife();
		for (int i = 0; i < getMaxlife(); i++) {
			if (currentLife >= 1) {
				ssLife.get(i).setXPos(0);
				currentLife -= 1;
			} else if (currentLife > 0 && currentLife < 1) {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH + Gap.COLUMGAP);
				currentLife -= 0.5;
			} else {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH * 2 + Gap.COLUMGAP * 2);
			}

		}
	}

	public void attack() {
	}
}
=======
				
=======

>>>>>>> origin/최낙연
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	// 주변 아이템 여부 체크
	public boolean nearItemCheck(Item item) {
		if (getXPlayerCenter() > item.getXItem() && getXPlayerCenter() < item.getXItem() + item.getSsItem().getWidth()
				&& getYPlayerCenter() > item.getYItem()
				&& getYPlayerCenter() < item.getYItem() + item.getSsItem().getHeight()) {
			return true;
		} else {
			return false;
		}
	}

	// 아이템 획득 종류 확인
	public void getItem() {
		for (int i = 0; i < items.size(); i++) {
			if (items.get(i).isDrop()) {
				if (nearItemCheck(items.get(i))) {
					items.get(i).setDrop(false);
					// Gubun String이 "bomb" 일때
					int luck = (int) (Math.random() * 2);

					if (items.get(i).getSsItem().getGubun() == "bomb") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {
							bombCount += 1;
							labomb.setText(Integer.toString(bombCount));
						} else if (luck == 0) {
							bombCount -= 1;
							labomb.setText(Integer.toString(bombCount));
						} // Gubun String이 "Power" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Power") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							powerNum+=2;
							lapower.setText(Integer.toString(powerNum));
								
						}
						else if(luck == 0) {
							powerNum--;
							lapower.setText(Integer.toString(powerNum));
							
						}
						// Gubun String이 "Speed" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Speed") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							moveSpeed += 3;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));

						}
						else if ( luck == 0) {
							moveSpeed --;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));
							
						}
					}
					else if (items.get(i).getSsItem().getGubun() == "AttackSpeed") {
						if (luck == 1) {

							attackspeedNum +=2;
							laattackspeed.setText(Integer.toString(attackspeedNum));

						}
						else if ( luck == 0) {
							attackspeedNum --;
							laattackspeed.setText(Integer.toString(attackspeedNum));
							
						}
					}
					System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
					getApp().remove(items.get(i).getSsItem());
					getApp().repaint();

				}
			}

		}
	}
}
>>>>>>> origin/최낙연

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-14 16:08:37.635
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-14 16:08:37.635
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-14 16:08:37.692
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package player;

import java.awt.Color;
import java.awt.Font;
import java.io.File;
import java.net.Socket;
import java.util.Vector;

import javax.imageio.ImageIO;
import javax.imageio.ImageTranscoder;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.xml.stream.events.StartDocument;

import player.Player;
import sword.SwordControl;
import SpriteSheet.SpriteSheet;
import imgSize.*;
import lombok.Data;
import monster.Monster;
import monster.Worm;

@Data

public class issac extends Player {
	private final static String TAG = "issac: ";
	private issac issac = this;
	private SpriteSheet ssHead, ssBody;
	private SpriteSheet ssTotal;
	private Vector<SpriteSheet> ssLife;
	private SwordControl swordControl;
	private Worm worm;
	private Vector<Monster> monsters;
	private Vector<wall> walls;
	private Vector<Item> items;
	private int xPlusBody = 7, yPlusBody = 30;
	private int yTotalSize;
	private int item1Count = 0;
	private int item2Count = 0;
	private int item3Count = 0;
	private int item4Count = 0;
	private int moveSpeed = 10;
	// 상하 좌우 이동 모션
	// 개수 및 수치 표시용 레이블 + 변수 선언 및 초기화
	private JLabel labomb;
	private JLabel laspeed;
	private JLabel lapower;
	private JLabel laattackspeed;
	private int bombCount = 0;
	private int speedNum = 11;
	private int powerNum = 1;
	private int attackspeedNum = 1;
	public issac(JFrame app, Vector<Monster> monsters ,  Vector<wall> walls, Vector<Item> items) {
		super(app);
		System.out.println(TAG + "make issac");
		init(monsters ,walls, items);
		setting();
		batch();

	}

	public void init(Vector<Monster> monsters ,Vector<wall> walls, Vector<Item> items) {
		this.walls = walls;
		this.items = items;
		this.monsters = monsters;
		ssHead = new SpriteSheet("issac/issac.png", "issacssHead", 0, 0, issacSize.issacHEADWIDTH,
				issacSize.issacHEADHEIGHT);
		ssBody = new SpriteSheet("issac/issac.png", "issacBody", 0, (issacSize.issacHEADHEIGHT + Gap.ROWGAP),
				issacSize.issacBODYWIDTH, issacSize.issacBODYHEIGHT);
		ssTotal = new SpriteSheet("issac/issac.png", "issacsBody", 0, yTotalSize, issacSize.issacTOTALWIDTH,
				issacSize.issacTOTALHEIGHT);
		yTotalSize = issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 4 + Gap.ROWGAP * 5;
		// 레이블 초기화
		labomb = new JLabel(Integer.toString(bombCount));
		laspeed = new JLabel(Integer.toString(speedNum - moveSpeed));
		lapower = new JLabel(Integer.toString(powerNum));
		laattackspeed = new JLabel(Integer.toString(attackspeedNum));
		ssLife = new Vector<SpriteSheet>();
		for (int i = 0; i < getLife(); i++) {
			this.ssLife.add(i,
					new SpriteSheet("issac/life.png", "life", 0, 0, Lifesize.LIFEWIDTH, Lifesize.LIFEHEIGHT));
		}
		for (int i = (int) getLife(); i < getMaxlife(); i++) {
			this.ssLife.add(new SpriteSheet("issac/life.png", "life", Lifesize.LIFEWIDTH * 2, 0, Lifesize.LIFEWIDTH,
					Lifesize.LIFEHEIGHT));
		}
	}

	public void setting() {
		setViewDirect(ViewDirect.DOWN);
		setXPlayer(480);
		setYPlayer(430);
		setAttackDamge(1);
		setLife(3);
		setXPlayerCenter(getXPlayer() + issacSize.issacHEADWIDTH / 2);
		setYPlayerCenter(getYPlayer() + issacSize.issacHEADHEIGHT);
		ssHead.drawObj(getXPlayer(), getYPlayer());
		ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
		// 폭탄 레이블 설정
		labomb.setSize(30, 30);
		labomb.setLocation(65, 50);
		labomb.setFont(new Font("바탕", Font.ITALIC, 25));
		labomb.setForeground(Color.WHITE);
		// 속도 레이블 설정
		lapower.setSize(30, 30);
		lapower.setLocation(65, 85);
		lapower.setFont(new Font("바탕", Font.ITALIC, 25));
		lapower.setForeground(Color.WHITE);
		// 속도 레이블 설정
		laspeed.setSize(40, 30);
		laspeed.setLocation(65, 120);
		laspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laspeed.setForeground(Color.WHITE);
		// 공속 레이블 설정
		laattackspeed.setSize(40,30);
		laattackspeed.setLocation(65, 155);
		laattackspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laattackspeed.setForeground(Color.WHITE);
		
		for (int i = 0; i < getMaxlife(); i++) {
			if (i <= getLife()) {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			} else {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			}

		}
	}

	public void batch() {
		getApp().add(ssHead, 0);
		getApp().add(ssBody, 1);
		// 폭탄 파워 속도 레이블 추가
		getApp().add(labomb);
		getApp().add(lapower);
		getApp().add(laspeed);
		getApp().add(laattackspeed);
		swordControl = new SwordControl(getApp());
		for (int i = 0; i < getMaxlife(); i++) {
			getApp().add(ssLife.get(i), 1);
		}
	}

	// 상하 좌우 이동 모션
	@Override
	public void moveRight() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isRight() == false) {
					setRight(true);
					setViewDirect(ViewDirect.RIGHT);
					while (isRight()) {
						if (getXPlayer() + issacSize.issacBODYWIDTH > 810) { // 벽이상 움직임 제한
							setRight(false);
							refreshDirect();
							break;
						}
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						setXPlayer(getXPlayer()+1);
						setXPlayerCenter(getXPlayerCenter()+1);
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall()
										&& getXPlayerCenter() < walls.get(i).getXwall() + RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setRight(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveLeft() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isLeft() == false) {
					setLeft(true);
					setViewDirect(ViewDirect.LEFT);
					while (isLeft()) {
						if (getXPlayer() < 130) {
							setLeft(false);
							refreshDirect();
							break;
						}
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {

								if (getXPlayerCenter() > walls.get(i).getXwall()
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setLeft(false);
							refreshDirect();
							break;
						}
						// 돌 충돌 체크 끝
						getItem();
						setXPlayer(getXPlayer() - 1);
						setXPlayerCenter(getXPlayerCenter() - 1);
						moveMotion();
						try {

							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveDown() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isDown() == false) {
					setDown(true);
					setViewDirect(ViewDirect.DOWN);
					while (isDown()) {
						if (getYPlayer() > 440) {
							setDown(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() + (issacSize.issacHEADHEIGHT - yPlusBody) + 5 > walls
												.get(i).getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveUp() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isUp() == false) {
					setUp(true);
					setViewDirect(ViewDirect.UP);
					while (isUp()) {
						if(getYPlayer()<100) {
							setUp(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer()-1);
						setYPlayerCenter(getYPlayerCenter()-1);
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() > walls.get(i).getYwall() && getYPlayerCenter()
												+ (issacSize.issacBODYHEIGHT - yPlusBody) < walls.get(i).getYwall()
														+ RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() - 1);
						setYPlayerCenter(getYPlayerCenter() - 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// // 가져올
																											// 기준이
							// 되는 X좌표가
							// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// // 않게하기위해 사용합니다.
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_down.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
								}
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_left.png"))
										swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
								}
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_up.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
								}
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_right.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
								}
=======
						}	
=======
						}
>>>>>>> origin/최낙연
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override // Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// 가져올 기준이
																											// 되는 X좌표가
																											// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// 않게하기위해 사용합니다.
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer()+xPlusBody, getYPlayer()+yPlusBody);
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						}
						try {
<<<<<<< HEAD
							Thread.sleep(15);
=======
							Thread.sleep(40);
>>>>>>> origin/최낙연
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
<<<<<<< HEAD
<<<<<<< HEAD

			}
		}).start();
	}

	public synchronized void attackMotion() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isPlayerAttack() == false) {
					setPlayerAttack(true);
					if (isPlayerAttack()) {
						int imgxlocation = 1;
						int imgylocation = 0;
						while (true) {
							setPlayerAttacking(true);
							if (getViewDirect() == ViewDirect.DOWN) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setXPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - (SwordMotionSize.IMGHEIGHT)
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_down.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() + 25);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.UP) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword()
										.setXPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.IMGHEIGHT - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_up.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() - 50);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.LEFT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos((SwordMotionSize.IMGHEIGHT) - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setUrl("sword/sword_left.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 60, getYPlayer() - 10);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.RIGHT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordMotionSize.IMGHEIGHT
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword()
										.setYPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setUrl("sword/sword_right.png");
								swordControl.getSsSword().drawObj(getXPlayer() + 20, getYPlayer() - 10);
								imgylocation++;
							}
							try {
								Thread.sleep(20);
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
				}
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	public void reDrawLife() {
		double currentLife = getLife();
		for (int i = 0; i < getMaxlife(); i++) {
			if (currentLife >= 1) {
				ssLife.get(i).setXPos(0);
				currentLife -= 1;
			} else if (currentLife > 0 && currentLife < 1) {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH + Gap.COLUMGAP);
				currentLife -= 0.5;
			} else {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH * 2 + Gap.COLUMGAP * 2);
			}

		}
	}

	public void attack() {
	}
}
=======
				
=======

>>>>>>> origin/최낙연
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	// 주변 아이템 여부 체크
	public boolean nearItemCheck(Item item) {
		if (getXPlayerCenter() > item.getXItem() && getXPlayerCenter() < item.getXItem() + item.getSsItem().getWidth()
				&& getYPlayerCenter() > item.getYItem()
				&& getYPlayerCenter() < item.getYItem() + item.getSsItem().getHeight()) {
			return true;
		} else {
			return false;
		}
	}

	// 아이템 획득 종류 확인
	public void getItem() {
		for (int i = 0; i < items.size(); i++) {
			if (items.get(i).isDrop()) {
				if (nearItemCheck(items.get(i))) {
					items.get(i).setDrop(false);
					// Gubun String이 "bomb" 일때
					int luck = (int) (Math.random() * 2);

					if (items.get(i).getSsItem().getGubun() == "bomb") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {
							bombCount += 1;
							labomb.setText(Integer.toString(bombCount));
						} else if (luck == 0) {
							bombCount -= 1;
							labomb.setText(Integer.toString(bombCount));
						} // Gubun String이 "Power" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Power") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							powerNum+=2;
							lapower.setText(Integer.toString(powerNum));
								
						}
						else if(luck == 0) {
							powerNum--;
							lapower.setText(Integer.toString(powerNum));
							
						}
						// Gubun String이 "Speed" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Speed") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							moveSpeed += 3;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));

						}
						else if ( luck == 0) {
							moveSpeed --;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));
							
						}
					}
					else if (items.get(i).getSsItem().getGubun() == "AttackSpeed") {
						if (luck == 1) {

							attackspeedNum +=2;
							laattackspeed.setText(Integer.toString(attackspeedNum));

						}
						else if ( luck == 0) {
							attackspeedNum --;
							laattackspeed.setText(Integer.toString(attackspeedNum));
							
						}
					}
					System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
					getApp().remove(items.get(i).getSsItem());
					getApp().repaint();

				}
			}

		}
	}
}
>>>>>>> origin/최낙연

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-14 16:08:37.692
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-14 16:08:37.693
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-14 16:08:39.676
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package player;

import java.awt.Color;
import java.awt.Font;
import java.io.File;
import java.net.Socket;
import java.util.Vector;

import javax.imageio.ImageIO;
import javax.imageio.ImageTranscoder;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.xml.stream.events.StartDocument;

import player.Player;
import sword.SwordControl;
import SpriteSheet.SpriteSheet;
import imgSize.*;
import lombok.Data;
import monster.Monster;
import monster.Worm;

@Data

public class issac extends Player {
	private final static String TAG = "issac: ";
	private issac issac = this;
	private SpriteSheet ssHead, ssBody;
	private SpriteSheet ssTotal;
	private Vector<SpriteSheet> ssLife;
	private SwordControl swordControl;
	private Worm worm;
	private Vector<Monster> monsters;
	private Vector<wall> walls;
	private Vector<Item> items;
	private int xPlusBody = 7, yPlusBody = 30;
	private int yTotalSize;
	private int item1Count = 0;
	private int item2Count = 0;
	private int item3Count = 0;
	private int item4Count = 0;
	private int moveSpeed = 10;
	// 상하 좌우 이동 모션
	// 개수 및 수치 표시용 레이블 + 변수 선언 및 초기화
	private JLabel labomb;
	private JLabel laspeed;
	private JLabel lapower;
	private JLabel laattackspeed;
	private int bombCount = 0;
	private int speedNum = 11;
	private int powerNum = 1;
	private int attackspeedNum = 1;
	public issac(JFrame app, Vector<Monster> monsters ,  Vector<wall> walls, Vector<Item> items) {
		super(app);
		System.out.println(TAG + "make issac");
		init(monsters ,walls, items);
		setting();
		batch();

	}

	public void init(Vector<Monster> monsters ,Vector<wall> walls, Vector<Item> items) {
		this.walls = walls;
		this.items = items;
		this.monsters = monsters;
		ssHead = new SpriteSheet("issac/issac.png", "issacssHead", 0, 0, issacSize.issacHEADWIDTH,
				issacSize.issacHEADHEIGHT);
		ssBody = new SpriteSheet("issac/issac.png", "issacBody", 0, (issacSize.issacHEADHEIGHT + Gap.ROWGAP),
				issacSize.issacBODYWIDTH, issacSize.issacBODYHEIGHT);
		ssTotal = new SpriteSheet("issac/issac.png", "issacsBody", 0, yTotalSize, issacSize.issacTOTALWIDTH,
				issacSize.issacTOTALHEIGHT);
		yTotalSize = issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 4 + Gap.ROWGAP * 5;
		// 레이블 초기화
		labomb = new JLabel(Integer.toString(bombCount));
		laspeed = new JLabel(Integer.toString(speedNum - moveSpeed));
		lapower = new JLabel(Integer.toString(powerNum));
		laattackspeed = new JLabel(Integer.toString(attackspeedNum));
		ssLife = new Vector<SpriteSheet>();
		for (int i = 0; i < getLife(); i++) {
			this.ssLife.add(i,
					new SpriteSheet("issac/life.png", "life", 0, 0, Lifesize.LIFEWIDTH, Lifesize.LIFEHEIGHT));
		}
		for (int i = (int) getLife(); i < getMaxlife(); i++) {
			this.ssLife.add(new SpriteSheet("issac/life.png", "life", Lifesize.LIFEWIDTH * 2, 0, Lifesize.LIFEWIDTH,
					Lifesize.LIFEHEIGHT));
		}
	}

	public void setting() {
		setViewDirect(ViewDirect.DOWN);
		setXPlayer(480);
		setYPlayer(430);
		setAttackDamge(1);
		setLife(3);
		setXPlayerCenter(getXPlayer() + issacSize.issacHEADWIDTH / 2);
		setYPlayerCenter(getYPlayer() + issacSize.issacHEADHEIGHT);
		ssHead.drawObj(getXPlayer(), getYPlayer());
		ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
		// 폭탄 레이블 설정
		labomb.setSize(30, 30);
		labomb.setLocation(65, 50);
		labomb.setFont(new Font("바탕", Font.ITALIC, 25));
		labomb.setForeground(Color.WHITE);
		// 속도 레이블 설정
		lapower.setSize(30, 30);
		lapower.setLocation(65, 85);
		lapower.setFont(new Font("바탕", Font.ITALIC, 25));
		lapower.setForeground(Color.WHITE);
		// 속도 레이블 설정
		laspeed.setSize(40, 30);
		laspeed.setLocation(65, 120);
		laspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laspeed.setForeground(Color.WHITE);
		// 공속 레이블 설정
		laattackspeed.setSize(40,30);
		laattackspeed.setLocation(65, 155);
		laattackspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laattackspeed.setForeground(Color.WHITE);
		
		for (int i = 0; i < getMaxlife(); i++) {
			if (i <= getLife()) {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			} else {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			}

		}
	}

	public void batch() {
		getApp().add(ssHead, 0);
		getApp().add(ssBody, 1);
		// 폭탄 파워 속도 레이블 추가
		getApp().add(labomb);
		getApp().add(lapower);
		getApp().add(laspeed);
		getApp().add(laattackspeed);
		swordControl = new SwordControl(getApp());
		for (int i = 0; i < getMaxlife(); i++) {
			getApp().add(ssLife.get(i), 1);
		}
	}

	// 상하 좌우 이동 모션
	@Override
	public void moveRight() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isRight() == false) {
					setRight(true);
					setViewDirect(ViewDirect.RIGHT);
					while (isRight()) {
						if (getXPlayer() + issacSize.issacBODYWIDTH > 810) { // 벽이상 움직임 제한
							setRight(false);
							refreshDirect();
							break;
						}
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						setXPlayer(getXPlayer()+1);
						setXPlayerCenter(getXPlayerCenter()+1);
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall()
										&& getXPlayerCenter() < walls.get(i).getXwall() + RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setRight(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveLeft() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isLeft() == false) {
					setLeft(true);
					setViewDirect(ViewDirect.LEFT);
					while (isLeft()) {
						if (getXPlayer() < 130) {
							setLeft(false);
							refreshDirect();
							break;
						}
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {

								if (getXPlayerCenter() > walls.get(i).getXwall()
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setLeft(false);
							refreshDirect();
							break;
						}
						// 돌 충돌 체크 끝
						getItem();
						setXPlayer(getXPlayer() - 1);
						setXPlayerCenter(getXPlayerCenter() - 1);
						moveMotion();
						try {

							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveDown() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isDown() == false) {
					setDown(true);
					setViewDirect(ViewDirect.DOWN);
					while (isDown()) {
						if (getYPlayer() > 440) {
							setDown(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() + (issacSize.issacHEADHEIGHT - yPlusBody) + 5 > walls
												.get(i).getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveUp() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isUp() == false) {
					setUp(true);
					setViewDirect(ViewDirect.UP);
					while (isUp()) {
						if(getYPlayer()<100) {
							setUp(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer()-1);
						setYPlayerCenter(getYPlayerCenter()-1);
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() > walls.get(i).getYwall() && getYPlayerCenter()
												+ (issacSize.issacBODYHEIGHT - yPlusBody) < walls.get(i).getYwall()
														+ RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() - 1);
						setYPlayerCenter(getYPlayerCenter() - 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// // 가져올
																											// 기준이
							// 되는 X좌표가
							// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// // 않게하기위해 사용합니다.
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_down.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
								}
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_left.png"))
										swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
								}
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_up.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
								}
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_right.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
								}
=======
						}	
=======
						}
>>>>>>> origin/최낙연
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override // Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// 가져올 기준이
																											// 되는 X좌표가
																											// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// 않게하기위해 사용합니다.
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer()+xPlusBody, getYPlayer()+yPlusBody);
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						}
						try {

							Thread.sleep(15);
=======
							Thread.sleep(40);
>>>>>>> origin/최낙연
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
<<<<<<< HEAD
<<<<<<< HEAD

			}
		}).start();
	}

	public synchronized void attackMotion() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isPlayerAttack() == false) {
					setPlayerAttack(true);
					if (isPlayerAttack()) {
						int imgxlocation = 1;
						int imgylocation = 0;
						while (true) {
							setPlayerAttacking(true);
							if (getViewDirect() == ViewDirect.DOWN) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setXPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - (SwordMotionSize.IMGHEIGHT)
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_down.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() + 25);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.UP) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword()
										.setXPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.IMGHEIGHT - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_up.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() - 50);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.LEFT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos((SwordMotionSize.IMGHEIGHT) - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setUrl("sword/sword_left.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 60, getYPlayer() - 10);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.RIGHT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordMotionSize.IMGHEIGHT
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword()
										.setYPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setUrl("sword/sword_right.png");
								swordControl.getSsSword().drawObj(getXPlayer() + 20, getYPlayer() - 10);
								imgylocation++;
							}
							try {
								Thread.sleep(20);
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
				}
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	public void reDrawLife() {
		double currentLife = getLife();
		for (int i = 0; i < getMaxlife(); i++) {
			if (currentLife >= 1) {
				ssLife.get(i).setXPos(0);
				currentLife -= 1;
			} else if (currentLife > 0 && currentLife < 1) {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH + Gap.COLUMGAP);
				currentLife -= 0.5;
			} else {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH * 2 + Gap.COLUMGAP * 2);
			}

		}
	}

	public void attack() {
	}
}
=======
				
=======

>>>>>>> origin/최낙연
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	// 주변 아이템 여부 체크
	public boolean nearItemCheck(Item item) {
		if (getXPlayerCenter() > item.getXItem() && getXPlayerCenter() < item.getXItem() + item.getSsItem().getWidth()
				&& getYPlayerCenter() > item.getYItem()
				&& getYPlayerCenter() < item.getYItem() + item.getSsItem().getHeight()) {
			return true;
		} else {
			return false;
		}
	}

	// 아이템 획득 종류 확인
	public void getItem() {
		for (int i = 0; i < items.size(); i++) {
			if (items.get(i).isDrop()) {
				if (nearItemCheck(items.get(i))) {
					items.get(i).setDrop(false);
					// Gubun String이 "bomb" 일때
					int luck = (int) (Math.random() * 2);

					if (items.get(i).getSsItem().getGubun() == "bomb") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {
							bombCount += 1;
							labomb.setText(Integer.toString(bombCount));
						} else if (luck == 0) {
							bombCount -= 1;
							labomb.setText(Integer.toString(bombCount));
						} // Gubun String이 "Power" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Power") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							powerNum+=2;
							lapower.setText(Integer.toString(powerNum));
								
						}
						else if(luck == 0) {
							powerNum--;
							lapower.setText(Integer.toString(powerNum));
							
						}
						// Gubun String이 "Speed" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Speed") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							moveSpeed += 3;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));

						}
						else if ( luck == 0) {
							moveSpeed --;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));
							
						}
					}
					else if (items.get(i).getSsItem().getGubun() == "AttackSpeed") {
						if (luck == 1) {

							attackspeedNum +=2;
							laattackspeed.setText(Integer.toString(attackspeedNum));

						}
						else if ( luck == 0) {
							attackspeedNum --;
							laattackspeed.setText(Integer.toString(attackspeedNum));
							
						}
					}
					System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
					getApp().remove(items.get(i).getSsItem());
					getApp().repaint();

				}
			}

		}
	}
}
>>>>>>> origin/최낙연

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-14 16:08:39.676
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-14 16:08:39.677
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-14 16:08:40.554
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package player;

import java.awt.Color;
import java.awt.Font;
import java.io.File;
import java.net.Socket;
import java.util.Vector;

import javax.imageio.ImageIO;
import javax.imageio.ImageTranscoder;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.xml.stream.events.StartDocument;

import player.Player;
import sword.SwordControl;
import SpriteSheet.SpriteSheet;
import imgSize.*;
import lombok.Data;
import monster.Monster;
import monster.Worm;

@Data

public class issac extends Player {
	private final static String TAG = "issac: ";
	private issac issac = this;
	private SpriteSheet ssHead, ssBody;
	private SpriteSheet ssTotal;
	private Vector<SpriteSheet> ssLife;
	private SwordControl swordControl;
	private Worm worm;
	private Vector<Monster> monsters;
	private Vector<wall> walls;
	private Vector<Item> items;
	private int xPlusBody = 7, yPlusBody = 30;
	private int yTotalSize;
	private int item1Count = 0;
	private int item2Count = 0;
	private int item3Count = 0;
	private int item4Count = 0;
	private int moveSpeed = 10;
	// 상하 좌우 이동 모션
	// 개수 및 수치 표시용 레이블 + 변수 선언 및 초기화
	private JLabel labomb;
	private JLabel laspeed;
	private JLabel lapower;
	private JLabel laattackspeed;
	private int bombCount = 0;
	private int speedNum = 11;
	private int powerNum = 1;
	private int attackspeedNum = 1;
	public issac(JFrame app, Vector<Monster> monsters ,  Vector<wall> walls, Vector<Item> items) {
		super(app);
		System.out.println(TAG + "make issac");
		init(monsters ,walls, items);
		setting();
		batch();

	}

	public void init(Vector<Monster> monsters ,Vector<wall> walls, Vector<Item> items) {
		this.walls = walls;
		this.items = items;
		this.monsters = monsters;
		ssHead = new SpriteSheet("issac/issac.png", "issacssHead", 0, 0, issacSize.issacHEADWIDTH,
				issacSize.issacHEADHEIGHT);
		ssBody = new SpriteSheet("issac/issac.png", "issacBody", 0, (issacSize.issacHEADHEIGHT + Gap.ROWGAP),
				issacSize.issacBODYWIDTH, issacSize.issacBODYHEIGHT);
		ssTotal = new SpriteSheet("issac/issac.png", "issacsBody", 0, yTotalSize, issacSize.issacTOTALWIDTH,
				issacSize.issacTOTALHEIGHT);
		yTotalSize = issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 4 + Gap.ROWGAP * 5;
		// 레이블 초기화
		labomb = new JLabel(Integer.toString(bombCount));
		laspeed = new JLabel(Integer.toString(speedNum - moveSpeed));
		lapower = new JLabel(Integer.toString(powerNum));
		laattackspeed = new JLabel(Integer.toString(attackspeedNum));
		ssLife = new Vector<SpriteSheet>();
		for (int i = 0; i < getLife(); i++) {
			this.ssLife.add(i,
					new SpriteSheet("issac/life.png", "life", 0, 0, Lifesize.LIFEWIDTH, Lifesize.LIFEHEIGHT));
		}
		for (int i = (int) getLife(); i < getMaxlife(); i++) {
			this.ssLife.add(new SpriteSheet("issac/life.png", "life", Lifesize.LIFEWIDTH * 2, 0, Lifesize.LIFEWIDTH,
					Lifesize.LIFEHEIGHT));
		}
	}

	public void setting() {
		setViewDirect(ViewDirect.DOWN);
		setXPlayer(480);
		setYPlayer(430);
		setAttackDamge(1);
		setLife(3);
		setXPlayerCenter(getXPlayer() + issacSize.issacHEADWIDTH / 2);
		setYPlayerCenter(getYPlayer() + issacSize.issacHEADHEIGHT);
		ssHead.drawObj(getXPlayer(), getYPlayer());
		ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
		// 폭탄 레이블 설정
		labomb.setSize(30, 30);
		labomb.setLocation(65, 50);
		labomb.setFont(new Font("바탕", Font.ITALIC, 25));
		labomb.setForeground(Color.WHITE);
		// 속도 레이블 설정
		lapower.setSize(30, 30);
		lapower.setLocation(65, 85);
		lapower.setFont(new Font("바탕", Font.ITALIC, 25));
		lapower.setForeground(Color.WHITE);
		// 속도 레이블 설정
		laspeed.setSize(40, 30);
		laspeed.setLocation(65, 120);
		laspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laspeed.setForeground(Color.WHITE);
		// 공속 레이블 설정
		laattackspeed.setSize(40,30);
		laattackspeed.setLocation(65, 155);
		laattackspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laattackspeed.setForeground(Color.WHITE);
		
		for (int i = 0; i < getMaxlife(); i++) {
			if (i <= getLife()) {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			} else {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			}

		}
	}

	public void batch() {
		getApp().add(ssHead, 0);
		getApp().add(ssBody, 1);
		// 폭탄 파워 속도 레이블 추가
		getApp().add(labomb);
		getApp().add(lapower);
		getApp().add(laspeed);
		getApp().add(laattackspeed);
		swordControl = new SwordControl(getApp());
		for (int i = 0; i < getMaxlife(); i++) {
			getApp().add(ssLife.get(i), 1);
		}
	}

	// 상하 좌우 이동 모션
	@Override
	public void moveRight() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isRight() == false) {
					setRight(true);
					setViewDirect(ViewDirect.RIGHT);
					while (isRight()) {
						if (getXPlayer() + issacSize.issacBODYWIDTH > 810) { // 벽이상 움직임 제한
							setRight(false);
							refreshDirect();
							break;
						}
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						setXPlayer(getXPlayer()+1);
						setXPlayerCenter(getXPlayerCenter()+1);
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall()
										&& getXPlayerCenter() < walls.get(i).getXwall() + RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setRight(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveLeft() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isLeft() == false) {
					setLeft(true);
					setViewDirect(ViewDirect.LEFT);
					while (isLeft()) {
						if (getXPlayer() < 130) {
							setLeft(false);
							refreshDirect();
							break;
						}
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {

								if (getXPlayerCenter() > walls.get(i).getXwall()
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setLeft(false);
							refreshDirect();
							break;
						}
						// 돌 충돌 체크 끝
						getItem();
						setXPlayer(getXPlayer() - 1);
						setXPlayerCenter(getXPlayerCenter() - 1);
						moveMotion();
						try {

							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveDown() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isDown() == false) {
					setDown(true);
					setViewDirect(ViewDirect.DOWN);
					while (isDown()) {
						if (getYPlayer() > 440) {
							setDown(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() + (issacSize.issacHEADHEIGHT - yPlusBody) + 5 > walls
												.get(i).getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveUp() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isUp() == false) {
					setUp(true);
					setViewDirect(ViewDirect.UP);
					while (isUp()) {
						if(getYPlayer()<100) {
							setUp(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer()-1);
						setYPlayerCenter(getYPlayerCenter()-1);
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() > walls.get(i).getYwall() && getYPlayerCenter()
												+ (issacSize.issacBODYHEIGHT - yPlusBody) < walls.get(i).getYwall()
														+ RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() - 1);
						setYPlayerCenter(getYPlayerCenter() - 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// // 가져올
																											// 기준이
							// 되는 X좌표가
							// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// // 않게하기위해 사용합니다.
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_down.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
								}
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_left.png"))
										swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
								}
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_up.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
								}
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_right.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
								}
=======
						}	
=======
						}
>>>>>>> origin/최낙연
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override // Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// 가져올 기준이
																											// 되는 X좌표가
																											// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// 않게하기위해 사용합니다.
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer()+xPlusBody, getYPlayer()+yPlusBody);
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						}
						try {

							Thread.sleep(15);

							Thread.sleep(40);
>>>>>>> origin/최낙연
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
<<<<<<< HEAD
<<<<<<< HEAD

			}
		}).start();
	}

	public synchronized void attackMotion() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isPlayerAttack() == false) {
					setPlayerAttack(true);
					if (isPlayerAttack()) {
						int imgxlocation = 1;
						int imgylocation = 0;
						while (true) {
							setPlayerAttacking(true);
							if (getViewDirect() == ViewDirect.DOWN) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setXPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - (SwordMotionSize.IMGHEIGHT)
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_down.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() + 25);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.UP) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword()
										.setXPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.IMGHEIGHT - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_up.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() - 50);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.LEFT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos((SwordMotionSize.IMGHEIGHT) - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setUrl("sword/sword_left.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 60, getYPlayer() - 10);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.RIGHT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordMotionSize.IMGHEIGHT
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword()
										.setYPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setUrl("sword/sword_right.png");
								swordControl.getSsSword().drawObj(getXPlayer() + 20, getYPlayer() - 10);
								imgylocation++;
							}
							try {
								Thread.sleep(20);
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
				}
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	public void reDrawLife() {
		double currentLife = getLife();
		for (int i = 0; i < getMaxlife(); i++) {
			if (currentLife >= 1) {
				ssLife.get(i).setXPos(0);
				currentLife -= 1;
			} else if (currentLife > 0 && currentLife < 1) {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH + Gap.COLUMGAP);
				currentLife -= 0.5;
			} else {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH * 2 + Gap.COLUMGAP * 2);
			}

		}
	}

	public void attack() {
	}
}
=======
				
=======

>>>>>>> origin/최낙연
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	// 주변 아이템 여부 체크
	public boolean nearItemCheck(Item item) {
		if (getXPlayerCenter() > item.getXItem() && getXPlayerCenter() < item.getXItem() + item.getSsItem().getWidth()
				&& getYPlayerCenter() > item.getYItem()
				&& getYPlayerCenter() < item.getYItem() + item.getSsItem().getHeight()) {
			return true;
		} else {
			return false;
		}
	}

	// 아이템 획득 종류 확인
	public void getItem() {
		for (int i = 0; i < items.size(); i++) {
			if (items.get(i).isDrop()) {
				if (nearItemCheck(items.get(i))) {
					items.get(i).setDrop(false);
					// Gubun String이 "bomb" 일때
					int luck = (int) (Math.random() * 2);

					if (items.get(i).getSsItem().getGubun() == "bomb") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {
							bombCount += 1;
							labomb.setText(Integer.toString(bombCount));
						} else if (luck == 0) {
							bombCount -= 1;
							labomb.setText(Integer.toString(bombCount));
						} // Gubun String이 "Power" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Power") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							powerNum+=2;
							lapower.setText(Integer.toString(powerNum));
								
						}
						else if(luck == 0) {
							powerNum--;
							lapower.setText(Integer.toString(powerNum));
							
						}
						// Gubun String이 "Speed" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Speed") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							moveSpeed += 3;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));

						}
						else if ( luck == 0) {
							moveSpeed --;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));
							
						}
					}
					else if (items.get(i).getSsItem().getGubun() == "AttackSpeed") {
						if (luck == 1) {

							attackspeedNum +=2;
							laattackspeed.setText(Integer.toString(attackspeedNum));

						}
						else if ( luck == 0) {
							attackspeedNum --;
							laattackspeed.setText(Integer.toString(attackspeedNum));
							
						}
					}
					System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
					getApp().remove(items.get(i).getSsItem());
					getApp().repaint();

				}
			}

		}
	}
}
>>>>>>> origin/최낙연

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-09-14 16:08:40.554
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-09-14 16:08:40.554
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:584)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-09-14 16:08:40.639
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package player;

import java.awt.Color;
import java.awt.Font;
import java.io.File;
import java.net.Socket;
import java.util.Vector;

import javax.imageio.ImageIO;
import javax.imageio.ImageTranscoder;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.xml.stream.events.StartDocument;

import player.Player;
import sword.SwordControl;
import SpriteSheet.SpriteSheet;
import imgSize.*;
import lombok.Data;
import monster.Monster;
import monster.Worm;

@Data

public class issac extends Player {
	private final static String TAG = "issac: ";
	private issac issac = this;
	private SpriteSheet ssHead, ssBody;
	private SpriteSheet ssTotal;
	private Vector<SpriteSheet> ssLife;
	private SwordControl swordControl;
	private Worm worm;
	private Vector<Monster> monsters;
	private Vector<wall> walls;
	private Vector<Item> items;
	private int xPlusBody = 7, yPlusBody = 30;
	private int yTotalSize;
	private int item1Count = 0;
	private int item2Count = 0;
	private int item3Count = 0;
	private int item4Count = 0;
	private int moveSpeed = 10;
	// 상하 좌우 이동 모션
	// 개수 및 수치 표시용 레이블 + 변수 선언 및 초기화
	private JLabel labomb;
	private JLabel laspeed;
	private JLabel lapower;
	private JLabel laattackspeed;
	private int bombCount = 0;
	private int speedNum = 11;
	private int powerNum = 1;
	private int attackspeedNum = 1;
	public issac(JFrame app, Vector<Monster> monsters ,  Vector<wall> walls, Vector<Item> items) {
		super(app);
		System.out.println(TAG + "make issac");
		init(monsters ,walls, items);
		setting();
		batch();

	}

	public void init(Vector<Monster> monsters ,Vector<wall> walls, Vector<Item> items) {
		this.walls = walls;
		this.items = items;
		this.monsters = monsters;
		ssHead = new SpriteSheet("issac/issac.png", "issacssHead", 0, 0, issacSize.issacHEADWIDTH,
				issacSize.issacHEADHEIGHT);
		ssBody = new SpriteSheet("issac/issac.png", "issacBody", 0, (issacSize.issacHEADHEIGHT + Gap.ROWGAP),
				issacSize.issacBODYWIDTH, issacSize.issacBODYHEIGHT);
		ssTotal = new SpriteSheet("issac/issac.png", "issacsBody", 0, yTotalSize, issacSize.issacTOTALWIDTH,
				issacSize.issacTOTALHEIGHT);
		yTotalSize = issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 4 + Gap.ROWGAP * 5;
		// 레이블 초기화
		labomb = new JLabel(Integer.toString(bombCount));
		laspeed = new JLabel(Integer.toString(speedNum - moveSpeed));
		lapower = new JLabel(Integer.toString(powerNum));
		laattackspeed = new JLabel(Integer.toString(attackspeedNum));
		ssLife = new Vector<SpriteSheet>();
		for (int i = 0; i < getLife(); i++) {
			this.ssLife.add(i,
					new SpriteSheet("issac/life.png", "life", 0, 0, Lifesize.LIFEWIDTH, Lifesize.LIFEHEIGHT));
		}
		for (int i = (int) getLife(); i < getMaxlife(); i++) {
			this.ssLife.add(new SpriteSheet("issac/life.png", "life", Lifesize.LIFEWIDTH * 2, 0, Lifesize.LIFEWIDTH,
					Lifesize.LIFEHEIGHT));
		}
	}

	public void setting() {
		setViewDirect(ViewDirect.DOWN);
		setXPlayer(480);
		setYPlayer(430);
		setAttackDamge(1);
		setLife(3);
		setXPlayerCenter(getXPlayer() + issacSize.issacHEADWIDTH / 2);
		setYPlayerCenter(getYPlayer() + issacSize.issacHEADHEIGHT);
		ssHead.drawObj(getXPlayer(), getYPlayer());
		ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
		// 폭탄 레이블 설정
		labomb.setSize(30, 30);
		labomb.setLocation(65, 50);
		labomb.setFont(new Font("바탕", Font.ITALIC, 25));
		labomb.setForeground(Color.WHITE);
		// 속도 레이블 설정
		lapower.setSize(30, 30);
		lapower.setLocation(65, 85);
		lapower.setFont(new Font("바탕", Font.ITALIC, 25));
		lapower.setForeground(Color.WHITE);
		// 속도 레이블 설정
		laspeed.setSize(40, 30);
		laspeed.setLocation(65, 120);
		laspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laspeed.setForeground(Color.WHITE);
		// 공속 레이블 설정
		laattackspeed.setSize(40,30);
		laattackspeed.setLocation(65, 155);
		laattackspeed.setFont(new Font("바탕", Font.ITALIC, 25));
		laattackspeed.setForeground(Color.WHITE);
		
		for (int i = 0; i < getMaxlife(); i++) {
			if (i <= getLife()) {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			} else {
				ssLife.get(i).drawObj(10 + (i * 30), 10);
			}

		}
	}

	public void batch() {
		getApp().add(ssHead, 0);
		getApp().add(ssBody, 1);
		// 폭탄 파워 속도 레이블 추가
		getApp().add(labomb);
		getApp().add(lapower);
		getApp().add(laspeed);
		getApp().add(laattackspeed);
		swordControl = new SwordControl(getApp());
		for (int i = 0; i < getMaxlife(); i++) {
			getApp().add(ssLife.get(i), 1);
		}
	}

	// 상하 좌우 이동 모션
	@Override
	public void moveRight() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isRight() == false) {
					setRight(true);
					setViewDirect(ViewDirect.RIGHT);
					while (isRight()) {
						if (getXPlayer() + issacSize.issacBODYWIDTH > 810) { // 벽이상 움직임 제한
							setRight(false);
							refreshDirect();
							break;
						}
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						setXPlayer(getXPlayer()+1);
						setXPlayerCenter(getXPlayerCenter()+1);
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall()
										&& getXPlayerCenter() < walls.get(i).getXwall() + RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setRight(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setXPlayer(getXPlayer() + 1);
						setXPlayerCenter(getXPlayerCenter() + 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveLeft() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isLeft() == false) {
					setLeft(true);
					setViewDirect(ViewDirect.LEFT);
					while (isLeft()) {
						if (getXPlayer() < 130) {
							setLeft(false);
							refreshDirect();
							break;
						}
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {

								if (getXPlayerCenter() > walls.get(i).getXwall()
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH
										&& getYPlayerCenter() + issacSize.issacHEADHEIGHT - yPlusBody > walls.get(i)
												.getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setLeft(false);
							refreshDirect();
							break;
						}
						// 돌 충돌 체크 끝
						getItem();
						setXPlayer(getXPlayer() - 1);
						setXPlayerCenter(getXPlayerCenter() - 1);
						moveMotion();
						try {

							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveDown() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isDown() == false) {
					setDown(true);
					setViewDirect(ViewDirect.DOWN);
					while (isDown()) {
						if (getYPlayer() > 440) {
							setDown(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						// 돌 충돌 체크 시작
						boolean isRockCollision = false;
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() + (issacSize.issacHEADHEIGHT - yPlusBody) + 5 > walls
												.get(i).getYwall()
										&& getYPlayerCenter() < walls.get(i).getYwall() + RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() + 1);// 플레이어 이동시 좌표값 변경
						setYPlayerCenter(getYPlayerCenter() + 1);// 중앙
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}
	@Override
	public void moveUp() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isUp() == false) {
					setUp(true);
					setViewDirect(ViewDirect.UP);
					while (isUp()) {
						if(getYPlayer()<100) {
							setUp(false);
							refreshDirect();
							break;
						}
						setYPlayer(getYPlayer()-1);
						setYPlayerCenter(getYPlayerCenter()-1);
						boolean isRockCollision = false;
						// 돌 충돌 체크 시작
						for (int i = 0; i < walls.size(); i++) {
							if (!walls.get(i).isBroken() && walls.get(i).getSswall().getGubun() == "rock") {
								if (getXPlayerCenter() + (issacSize.issacHEADWIDTH / 2) > walls.get(i).getXwall() + 5
										&& getXPlayerCenter() - (issacSize.issacHEADWIDTH / 2) < walls.get(i).getXwall()
												+ RockSize.WIDTH - 5
										&& getYPlayerCenter() > walls.get(i).getYwall() && getYPlayerCenter()
												+ (issacSize.issacBODYHEIGHT - yPlusBody) < walls.get(i).getYwall()
														+ RockSize.HEIGHT) {
									isRockCollision = true;
									break;
								}
							}
						}
						if (isRockCollision) {
							setUp(false);
							refreshDirect();
							break;
						}
						getItem();
						// 돌 충돌 체크 끝
						setYPlayer(getYPlayer() - 1);
						setYPlayerCenter(getYPlayerCenter() - 1);
						moveMotion();
						try {
							Thread.sleep(moveSpeed);
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// // 가져올
																											// 기준이
							// 되는 X좌표가
							// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// // 않게하기위해 사용합니다.
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_down.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
								}
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_left.png"))
										swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
								}
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_up.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
								}
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								if (!isPlayerAttacking()) {
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									if (swordControl.getSsSword().getUrl().equals("sword/sword_right.png"))
										swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
								}
=======
						}	
=======
						}
>>>>>>> origin/최낙연
					}
					System.out.println("캐릭터생성");
					ssBody.setXPos(0);
					ssHead.drawObj(getXPlayer(), getYPlayer());
					ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
				}
			}
		}).start();
	}

	@Override // Override
	public void moveMotion() { // 움직이는 동작중 이미지 갱신
		// Down을 기준으로 설명하겠습니다 나머지 내용은 ColumGap과 RowGap, HEIGHT, WIDTH로 상하 좌우가 구분됩니다
		new Thread(new Runnable() {

			@Override
			public void run() {
				int motion = 0;
				if (isPlayerMoveStart() == false) {
					setPlayerMoveStart(true);
					while (true) {
						if (isDown() && getViewDirect() == ViewDirect.DOWN) {
							if (motion > 9) // 상하좌우 방향 모션 개수와 동일 0~9 10개
								motion = 0;// 마지막사진 도착후 처음으로 순환을 위한 if문 종료
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion)); // XPos는 사진에서
																											// 가져올 기준이
																											// 되는 X좌표가
																											// 됩니다
							if (getViewDirect() == ViewDirect.DOWN) {
								ssHead.setXPos(0); // 첫번째 사진이므로 0 다른 내용은 images/issac/issac.img에서 순서 확인하시면 됩니다.
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);// X좌표로 순서를 정하고 Y좌표는 사진사이의 간격과
																						// 머리 이미지를 무시해야 하기에 머리 이미지의 크기만큼
																						// 더해서 좌표값을 내려줍니다
								ssHead.drawObj(getXPlayer(), getYPlayer()); // 그려지는 기준점이 되는 캐릭터(몬스터의) 좌표값을 설정합니다.
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);// X와Y좌표를 기준으로 머리를
																									// 생성하고 머리와 몸이 겹치지
																									// 않게하기위해 사용합니다.
								motion += 1;
							}
						} else if (isLeft() && getViewDirect() == ViewDirect.LEFT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.LEFT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 6 + Gap.COLUMGAP * 6);
								ssBody.setYPos(
										issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT * 2 + Gap.ROWGAP * 3);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isUp() && getViewDirect() == ViewDirect.UP) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.UP) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 4 + Gap.COLUMGAP * 4);
								ssBody.setYPos(issacSize.issacHEADWIDTH + Gap.COLUMGAP);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						} else if (isRight() && getViewDirect() == ViewDirect.RIGHT) {
							if (motion > 9)
								motion = 0;
							ssBody.setXPos((issacSize.issacBODYWIDTH * motion) + (Gap.COLUMGAP * motion));
							if (getViewDirect() == ViewDirect.RIGHT) {
								ssHead.setXPos(issacSize.issacHEADWIDTH * 2 + Gap.COLUMGAP * 2);
								ssBody.setYPos(issacSize.issacHEADHEIGHT + issacSize.issacBODYHEIGHT + Gap.ROWGAP * 2);
								ssHead.drawObj(getXPlayer(), getYPlayer());
								ssBody.drawObj(getXPlayer()+xPlusBody, getYPlayer()+yPlusBody);
								ssBody.drawObj(getXPlayer() + xPlusBody, getYPlayer() + yPlusBody);
								motion += 1;
							}
						}
						try {

							Thread.sleep(15);

							Thread.sleep(40);
>>>>>>> origin/최낙연
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
<<<<<<< HEAD
<<<<<<< HEAD

			}
		}).start();
	}

	public synchronized void attackMotion() {
		new Thread(new Runnable() {
			@Override
			public void run() {
				if (isPlayerAttack() == false) {
					setPlayerAttack(true);
					if (isPlayerAttack()) {
						int imgxlocation = 1;
						int imgylocation = 0;
						while (true) {
							setPlayerAttacking(true);
							if (getViewDirect() == ViewDirect.DOWN) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setYPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT - 2);
									swordControl.getSsSword().setUrl("sword/sword_down.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() + 50);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setXPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - (SwordMotionSize.IMGHEIGHT)
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_down.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() + 25);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.UP) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDXGAP + 2);
									swordControl.getSsSword().setYPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 2);
									swordControl.getSsSword().setWidth(SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDYHEIGHT);
									swordControl.getSsSword().setUrl("sword/sword_up.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 12, getYPlayer() - 25);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setHeight(SwordMotionSize.HEIGHT);
								swordControl.getSsSword()
										.setXPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.IMGHEIGHT - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setUrl("sword/sword_up.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 28, getYPlayer() - 50);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.LEFT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordSize.SWORDYGAP
											- SwordSize.SWORDYHEIGHT + 3);
									swordControl.getSsSword().setYPos(
											SwordSize.SWORDIMGWIDTH - SwordSize.SWORDXGAP - SwordSize.SWORDWIDTH - 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_left.png");
									swordControl.getSsSword().drawObj(getXPlayer() - 36, getYPlayer() + 29);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos((SwordMotionSize.IMGHEIGHT) - SwordMotionSize.HEIGHT
										- (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword().setYPos(SwordMotionSize.WIDTH * imgxlocation);
								swordControl.getSsSword().setUrl("sword/sword_left.png");
								swordControl.getSsSword().drawObj(getXPlayer() - 60, getYPlayer() - 10);
								imgylocation++;
							} else if (getViewDirect() == ViewDirect.RIGHT) {
								if (imgxlocation == 1 && imgylocation > 3) {
									imgylocation = 0;
									imgxlocation--;
								}
								if (imgxlocation == 0 && imgylocation > 2) {
									imgxlocation = 1;
									imgylocation = 0;
									setPlayerAttacking(false);
									swordControl.getSsSword().setXPos(SwordSize.SWORDYGAP);
									swordControl.getSsSword().setYPos(SwordSize.SWORDXGAP + 1);
									swordControl.getSsSword().setWidth(SwordSize.SWORDYHEIGHT - 1);
									swordControl.getSsSword().setHeight(SwordSize.SWORDWIDTH);
									swordControl.getSsSword().setUrl("sword/sword_right.png");
									swordControl.getSsSword().drawObj(getXPlayer() + 34, getYPlayer() + 28);
									break;
								}
								swordControl.getSsSword().setWidth(SwordMotionSize.HEIGHT);
								swordControl.getSsSword().setHeight(SwordMotionSize.WIDTH);
								swordControl.getSsSword().setXPos(SwordSize.SWORDIMGHEIGHT - SwordMotionSize.IMGHEIGHT
										+ (SwordMotionSize.HEIGHT * imgylocation));
								swordControl.getSsSword()
										.setYPos(SwordMotionSize.WIDTH - (SwordMotionSize.WIDTH * imgxlocation));
								swordControl.getSsSword().setUrl("sword/sword_right.png");
								swordControl.getSsSword().drawObj(getXPlayer() + 20, getYPlayer() - 10);
								imgylocation++;
							}
							try {
								Thread.sleep(20);
							} catch (Exception e) {
								e.printStackTrace();
							}
						}
					}
				}
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	public void reDrawLife() {
		double currentLife = getLife();
		for (int i = 0; i < getMaxlife(); i++) {
			if (currentLife >= 1) {
				ssLife.get(i).setXPos(0);
				currentLife -= 1;
			} else if (currentLife > 0 && currentLife < 1) {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH + Gap.COLUMGAP);
				currentLife -= 0.5;
			} else {
				ssLife.get(i).setXPos(Lifesize.LIFEWIDTH * 2 + Gap.COLUMGAP * 2);
			}

		}
	}

	public void attack() {
	}
}
=======
				
=======

>>>>>>> origin/최낙연
			}
		}).start();
	}

	public void refreshDirect() {
		if (issac.isDown()) {
			issac.setViewDirect(ViewDirect.DOWN);
		}
		if (issac.isLeft()) {
			issac.setViewDirect(ViewDirect.LEFT);
		}
		if (issac.isUp()) {
			issac.setViewDirect(ViewDirect.UP);
		}
		if (issac.isRight()) {
			issac.setViewDirect(ViewDirect.RIGHT);
		}
	}

	// 주변 아이템 여부 체크
	public boolean nearItemCheck(Item item) {
		if (getXPlayerCenter() > item.getXItem() && getXPlayerCenter() < item.getXItem() + item.getSsItem().getWidth()
				&& getYPlayerCenter() > item.getYItem()
				&& getYPlayerCenter() < item.getYItem() + item.getSsItem().getHeight()) {
			return true;
		} else {
			return false;
		}
	}

	// 아이템 획득 종류 확인
	public void getItem() {
		for (int i = 0; i < items.size(); i++) {
			if (items.get(i).isDrop()) {
				if (nearItemCheck(items.get(i))) {
					items.get(i).setDrop(false);
					// Gubun String이 "bomb" 일때
					int luck = (int) (Math.random() * 2);

					if (items.get(i).getSsItem().getGubun() == "bomb") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {
							bombCount += 1;
							labomb.setText(Integer.toString(bombCount));
						} else if (luck == 0) {
							bombCount -= 1;
							labomb.setText(Integer.toString(bombCount));
						} // Gubun String이 "Power" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Power") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							powerNum+=2;
							lapower.setText(Integer.toString(powerNum));
								
						}
						else if(luck == 0) {
							powerNum--;
							lapower.setText(Integer.toString(powerNum));
							
						}
						// Gubun String이 "Speed" 일때
					} else if (items.get(i).getSsItem().getGubun() == "Speed") {
						// System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
						if (luck == 1) {

							moveSpeed += 3;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));

						}
						else if ( luck == 0) {
							moveSpeed --;
							laspeed.setText(Integer.toString(speedNum - moveSpeed));
							
						}
					}
					else if (items.get(i).getSsItem().getGubun() == "AttackSpeed") {
						if (luck == 1) {

							attackspeedNum +=2;
							laattackspeed.setText(Integer.toString(attackspeedNum));

						}
						else if ( luck == 0) {
							attackspeedNum --;
							laattackspeed.setText(Integer.toString(attackspeedNum));
							
						}
					}
					System.out.println(items.get(i).getSsItem().getGubun() + " 발견");
					getApp().remove(items.get(i).getSsItem());
					getApp().repaint();

				}
			}

		}
	}
}
>>>>>>> origin/최낙연

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-09-14 16:08:40.640
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-09-14 16:08:40.640
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3919)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3344)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3121)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3570)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3153)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3079)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2286)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3103)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:429)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2908)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1966)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3161)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3456)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY Activator 4 0 2023-09-14 16:13:09.666
!MESSAGE NullPointerException: Cannot invoke "org.springsource.ide.eclipse.commons.livexp.core.LiveSetVariable.getValue()" because "this.this$0.applications" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.springsource.ide.eclipse.commons.livexp.core.LiveSetVariable.getValue()" because "this.this$0.applications" is null
	at org.springframework.ide.eclipse.boot.dash.model.LocalBootDashModel$2.bundleChanged(LocalBootDashModel.java:157)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.dispatchEvent(BundleContextImpl.java:949)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)
!SESSION 2023-09-14 16:18:27.956 -----------------------------------------------
eclipse.buildId=4.28.0.20230608-1200
java.version=17.0.8.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=ko_KR
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.emf.ecore 2 0 2023-09-14 16:18:29.734
!MESSAGE Both 'org.eclipse.jst.j2ee.core' and 'org.eclipse.jst.j2ee.core' register a package for 'application.xmi'

!ENTRY org.eclipse.e4.ui.css.swt.theme 4 0 2023-09-14 16:18:43.685
!MESSAGE /css/gef_dark.css
!STACK 0
java.io.FileNotFoundException: /css/gef_dark.css
	at org.eclipse.osgi.storage.url.bundleentry.Handler.findBundleEntry(Handler.java:55)
	at org.eclipse.osgi.storage.url.BundleResourceHandler.openConnection(BundleResourceHandler.java:182)
	at java.base/java.net.URL.openConnection(URL.java:1094)
	at org.eclipse.osgi.storage.url.BundleURLConverter.resolve(BundleURLConverter.java:55)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.core.internal.runtime.PlatformURLConverter.resolve(PlatformURLConverter.java:53)
	at org.eclipse.core.runtime.FileLocator.resolve(FileLocator.java:288)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:468)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:436)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.setTheme(ThemeEngine.java:428)
	at org.eclipse.e4.ui.css.swt.internal.theme.ThemeEngine.restore(ThemeEngine.java:624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.setCSSTheme(PartRenderingEngine.java:1417)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.initializeStyling(PartRenderingEngine.java:1324)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1050)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)

!ENTRY org.eclipse.jface 2 0 2023-09-14 16:18:43.948
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-14 16:18:43.948
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-14 16:18:43.948
!MESSAGE A conflict occurred for ALT+CTRL+T:
Binding(ALT+CTRL+T,
	ParameterizedCommand(Command(org.eclipse.tm.terminal.connector.local.command.launch,Open Local Terminal on Selection,
		,
		Category(org.eclipse.tm.terminal.view.ui.commands.category,Terminal Commands,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.tm.terminal.connector.local.command.launch"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+CTRL+T,
	ParameterizedCommand(Command(pl.szpinda.plugin.tomcat.commands.tomcatStartStop,Tomcat start,stop,
		,
		Category(pl.szpinda.plugin.tomcat.commands.category.key,Tomcat keys,null,true),
		WorkbenchHandlerServiceHandler("pl.szpinda.plugin.tomcat.commands.tomcatStartStop"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-14 16:18:47.314
!MESSAGE Command list starting LS: org.springframework.tooling.boot.ls
START:
C:\eclipse\plugins\org.eclipse.justj.openjdk.hotspot.jre.full.win32.x86_64_17.0.8.v20230831-1047\jre\bin\javaw.exe
-cp
C:\eclipse\plugins\org.springframework.tooling.boot.ls_1.48.0.202308011907\servers\spring-boot-language-server\BOOT-INF\classes;C:\eclipse\plugins\org.springframework.tooling.boot.ls_1.48.0.202308011907\servers\spring-boot-language-server\BOOT-INF\lib\*
-Dsts.lsp.client=eclipse
-Dlsp.completions.indentation.enable=true
-Xmx1024m
-XX:+HeapDumpOnOutOfMemoryError
-XX:TieredStopAtLevel=1
-Xlog:jni+resolve=off
-Dspring.config.location=file:C:\eclipse\plugins\org.springframework.tooling.boot.ls_1.48.0.202308011907\servers\spring-boot-language-server\BOOT-INF\classes\application.properties
-XX:ErrorFile=C:/Users/ITSC/Desktop/miniproject/miniproject/.metadata/.plugins/org.springframework.tooling.boot.ls/fatal-error-spring-boot_1694675927314
org.springframework.ide.vscode.boot.app.BootLanguageServerBootApp
--languageserver.hover-timeout=225
END

!ENTRY org.springframework.tooling.boot.ls 1 0 2023-09-14 16:18:47.314
!MESSAGE DelegatingStreamConnectionProvider - Starting Boot LS

!ENTRY org.springframework.tooling.ls.eclipse.commons 1 0 2023-09-14 16:18:47.325
!MESSAGE Started org.springframework.tooling.boot.ls LS process 6764

!ENTRY org.eclipse.egit.ui 2 0 2023-09-14 16:18:48.321
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\ITSC'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.lsp4e 2 0 2023-09-14 16:18:52.225
!MESSAGE Timeout waiting for data to generate LS hover
!STACK 0
java.util.concurrent.TimeoutException
	at java.base/java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:1960)
	at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:2095)
	at org.eclipse.lsp4e.jdt.LSJavaHoverProvider.getHoverInfo2(LSJavaHoverProvider.java:65)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY Activator 4 0 2023-09-14 16:29:19.739
!MESSAGE NullPointerException: Cannot invoke "org.springsource.ide.eclipse.commons.livexp.core.LiveSetVariable.getValue()" because "this.this$0.applications" is null
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.springsource.ide.eclipse.commons.livexp.core.LiveSetVariable.getValue()" because "this.this$0.applications" is null
	at org.springframework.ide.eclipse.boot.dash.model.LocalBootDashModel$2.bundleChanged(LocalBootDashModel.java:157)
	at org.eclipse.osgi.internal.framework.BundleContextImpl.dispatchEvent(BundleContextImpl.java:949)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.mylyn.commons.ui 4 0 2023-09-14 16:38:58.357
!MESSAGE For input string: "or" under radix 16
!STACK 0
java.lang.NumberFormatException: For input string: "or" under radix 16
	at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67)
	at java.base/java.lang.Integer.parseInt(Integer.java:668)
	at org.eclipse.mylyn.internal.commons.ui.E4ThemeColor.getRGBFromCssString(E4ThemeColor.java:57)
	at org.eclipse.mylyn.commons.ui.GradientColors.getRGBFromTheme(GradientColors.java:211)
	at org.eclipse.mylyn.commons.ui.GradientColors.getBackground(GradientColors.java:190)
	at org.eclipse.mylyn.commons.ui.GradientColors.createBorderColor(GradientColors.java:78)
	at org.eclipse.mylyn.commons.ui.GradientColors.createColors(GradientColors.java:54)
	at org.eclipse.mylyn.commons.ui.GradientColors.<init>(GradientColors.java:50)
	at org.eclipse.mylyn.commons.ui.GradientToolTip.initResources(GradientToolTip.java:49)
	at org.eclipse.mylyn.commons.ui.GradientToolTip.<init>(GradientToolTip.java:44)
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListToolTip.<init>(TaskListToolTip.java:126)
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListFilteredTree.createActiveTaskComposite(TaskListFilteredTree.java:423)
	at org.eclipse.mylyn.commons.workbench.AbstractFilteredTree.createFilterControls(AbstractFilteredTree.java:182)
	at org.eclipse.ui.dialogs.FilteredTree.createControl(FilteredTree.java:362)
	at org.eclipse.mylyn.commons.workbench.EnhancedFilteredTree.createControl(EnhancedFilteredTree.java:61)
	at org.eclipse.mylyn.commons.workbench.AbstractFilteredTree.createControl(AbstractFilteredTree.java:92)
	at org.eclipse.ui.dialogs.FilteredTree.init(FilteredTree.java:331)
	at org.eclipse.ui.dialogs.FilteredTree.<init>(FilteredTree.java:289)
	at org.eclipse.mylyn.commons.workbench.EnhancedFilteredTree.<init>(EnhancedFilteredTree.java:48)
	at org.eclipse.mylyn.commons.workbench.AbstractFilteredTree.<init>(AbstractFilteredTree.java:71)
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListFilteredTree.<init>(TaskListFilteredTree.java:135)
	at org.eclipse.mylyn.internal.tasks.ui.views.TaskListView.createPartControl(TaskListView.java:591)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.createPartControl(CompatibilityPart.java:158)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityView.createPartControl(CompatibilityView.java:155)
	at org.eclipse.ui.internal.e4.compatibility.CompatibilityPart.create(CompatibilityPart.java:365)
	at jdk.internal.reflect.GeneratedMethodAccessor84.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:987)
	at org.eclipse.e4.core.internal.di.InjectorImpl.processAnnotated(InjectorImpl.java:952)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalInject(InjectorImpl.java:141)
	at org.eclipse.e4.core.internal.di.InjectorImpl.internalMake(InjectorImpl.java:395)
	at org.eclipse.e4.core.internal.di.InjectorImpl.make(InjectorImpl.java:322)
	at org.eclipse.e4.core.contexts.ContextInjectionFactory.make(ContextInjectionFactory.java:202)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.createFromBundle(ReflectionContributionFactory.java:91)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.doCreate(ReflectionContributionFactory.java:60)
	at org.eclipse.e4.ui.internal.workbench.ReflectionContributionFactory.create(ReflectionContributionFactory.java:42)
	at org.eclipse.e4.ui.workbench.renderers.swt.ContributedPartRenderer.createWidget(ContributedPartRenderer.java:132)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$1.run(PartRenderingEngine.java:544)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:528)
	at org.eclipse.e4.ui.workbench.renderers.swt.ElementReferenceRenderer.createWidget(ElementReferenceRenderer.java:73)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createWidget(PartRenderingEngine.java:995)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:659)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.safeCreateGui(PartRenderingEngine.java:763)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$2.run(PartRenderingEngine.java:728)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.createGui(PartRenderingEngine.java:712)
	at org.eclipse.e4.ui.internal.workbench.PartServiceImpl.lambda$0(PartServiceImpl.java:110)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.lambda$0(UIEventHandler.java:38)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.services.internal.events.UIEventHandler.handleEvent(UIEventHandler.java:38)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElementGen(ElementContainerImpl.java:170)
	at org.eclipse.e4.ui.model.application.ui.impl.ElementContainerImpl.setSelectedElement(ElementContainerImpl.java:188)
	at org.eclipse.e4.ui.workbench.addons.minmax.TrimStack.restoreStack(TrimStack.java:916)
	at org.eclipse.e4.ui.workbench.addons.minmax.MinMaxAddon.restore(MinMaxAddon.java:693)
	at org.eclipse.e4.ui.workbench.addons.minmax.MinMaxAddon.subscribeTopicTagsChanged(MinMaxAddon.java:413)
	at jdk.internal.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.remove(NotifyingListImpl.java:725)
	at org.eclipse.emf.common.util.AbstractEList.remove(AbstractEList.java:456)
	at org.eclipse.e4.ui.workbench.addons.minmax.MinMaxAddon.unzoom(MinMaxAddon.java:925)
	at org.eclipse.e4.ui.workbench.addons.minmax.MinMaxAddon.subscribeTopicTagsChanged(MinMaxAddon.java:415)
	at jdk.internal.reflect.GeneratedMethodAccessor20.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.e4.core.internal.di.MethodRequestor.execute(MethodRequestor.java:58)
	at org.eclipse.swt.widgets.Synchronizer.syncExec(Synchronizer.java:183)
	at org.eclipse.ui.internal.UISynchronizer.syncExec(UISynchronizer.java:133)
	at org.eclipse.swt.widgets.Display.syncExec(Display.java:4803)
	at org.eclipse.e4.ui.workbench.swt.DisplayUISynchronize.syncExec(DisplayUISynchronize.java:34)
	at org.eclipse.e4.ui.internal.di.UIEventObjectSupplier$UIEventHandler.handleEvent(UIEventObjectSupplier.java:64)
	at org.eclipse.equinox.internal.event.EventHandlerWrapper.handleEvent(EventHandlerWrapper.java:205)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:203)
	at org.eclipse.equinox.internal.event.EventHandlerTracker.dispatchEvent(EventHandlerTracker.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.ListenerQueue.dispatchEventSynchronous(ListenerQueue.java:151)
	at org.eclipse.equinox.internal.event.EventAdminImpl.dispatchEvent(EventAdminImpl.java:133)
	at org.eclipse.equinox.internal.event.EventAdminImpl.sendEvent(EventAdminImpl.java:75)
	at org.eclipse.equinox.internal.event.EventComponent.sendEvent(EventComponent.java:44)
	at org.eclipse.e4.ui.services.internal.events.EventBroker.send(EventBroker.java:55)
	at org.eclipse.e4.ui.internal.workbench.UIEventPublisher.notifyChanged(UIEventPublisher.java:63)
	at org.eclipse.emf.common.notify.impl.BasicNotifierImpl.eNotify(BasicNotifierImpl.java:424)
	at org.eclipse.emf.ecore.util.EcoreEList.dispatchNotification(EcoreEList.java:249)
	at org.eclipse.emf.common.notify.impl.NotifyingListImpl.remove(NotifyingListImpl.java:725)
	at org.eclipse.emf.common.util.AbstractEList.remove(AbstractEList.java:456)
	at org.eclipse.e4.ui.workbench.addons.minmax.MinMaxAddon.setState(MinMaxAddon.java:216)
	at org.eclipse.e4.ui.workbench.addons.minmax.MinMaxAddon$2.mouseDoubleClick(MinMaxAddon.java:198)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:200)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4274)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1066)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4072)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3660)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1155)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:643)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:550)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:171)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:402)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
